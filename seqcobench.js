var DATA = [
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_for_while_loop", "transformed_code": "def positive_count(nums):\n    from array import array\n    n = len(nums)\n    n1 = 0\n    _x_i = 0\n    while _x_i < len(nums):\n        x = nums[_x_i]\n       \n        if x > 0:\n            n1 += 1\n        else:\n            None\n        _x_i += 1\n    return round(n1 / n, 2)", "label": 1, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_operand_swap", "transformed_code": "def positive_count(nums):\n    from array import array\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n       \n        if 0 < x:\n            n1 += 1\n        else:\n            None\n    return round(n1 / n, 2)", "label": 1, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_rename_variable_cb", "transformed_code": "def positive_count(nums):\n    from array import array\n    n = len(nums)\n    n2 = 0\n    for x in nums:\n       \n        if x > 0:\n            n2 += 1\n        else:\n            None\n    return round(n2 / n, 2)", "label": 1, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_rename_variable_naive", "transformed_code": "def positive_count(nums):\n    from array import array\n    n = len(nums)\n    VAR_0 = 0\n    for x in nums:\n       \n        if x > 0:\n            VAR_0 += 1\n        else:\n            None\n    return round(VAR_0 / n, 2)", "label": 1, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_rename_variable_rn", "transformed_code": "def positive_count(e81w):\n    from array import array\n    n = len(e81w)\n    n1 = 0\n    for x in e81w:\n       \n        if x > 0:\n            n1 += 1\n        else:\n            None\n    return round(n1 / n, 2)", "label": 1, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_add_sub_variable", "transformed_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 -= 1\n        else:\n          None\n    return round(n1/n,2)", "label": 0, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_div_mul_variable", "transformed_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1*n,2)", "label": 0, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "label": 0, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 439, "dataset": "mbpp"},
{"original_code": "def positive_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 439, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_dead_code_insert", "transformed_code": "def largest_neg(list1):\n    if False:\n        if x < max:\n            max = x\n    max = list1[0]\n    for x in list1:\n       \n        if x < max:\n            max = x\n    return max", "label": 1, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_for_while_loop", "transformed_code": "def largest_neg(list1):\n    max = list1[0]\n    _x_i = 0\n    while _x_i < len(list1):\n        x = list1[_x_i]\n       \n        if x < max:\n            max = x\n        _x_i += 1\n    return max", "label": 1, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_operand_swap", "transformed_code": "def largest_neg(list1):\n    max = list1[0]\n    for x in list1:\n       \n        if max > x:\n            max = x\n    return max", "label": 1, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_rename_variable_cb", "transformed_code": "def largest_neg(list1):\n    x2 = list1[0]\n    for x in list1:\n       \n        if x < x2:\n            x2 = x\n    return x2", "label": 1, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_rename_variable_naive", "transformed_code": "def largest_neg(list1):\n    VAR_0 = list1[0]\n    for x in list1:\n       \n        if x < VAR_0:\n            VAR_0 = x\n    return VAR_0", "label": 1, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_rename_variable_rn", "transformed_code": "def largest_neg(list1):\n    Y29 = list1[0]\n    for x in list1:\n       \n        if x < Y29:\n            Y29 = x\n    return Y29", "label": 1, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "label": 0, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 440, "dataset": "mbpp"},
{"original_code": "def largest_neg(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 440, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def index_multiplication(test_tup1, test_tup2):\n    res = tuple(\n        tuple(a * b for a, b in zip(tup1, tup2))\n       \n        for tup1, tup2 in zip(test_tup1, test_tup2)\n    )\n    return res", "label": 1, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_for_while_loop", "transformed_code": "def index_multiplication(test_tup1, test_tup2):\n    res = tuple(\n        tuple(a * b for a, b in zip(tup1, tup2))\n       \n        for tup1, tup2 in zip(test_tup1, test_tup2)\n    )\n    return res", "label": 1, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_operand_swap", "transformed_code": "def index_multiplication(test_tup1, test_tup2):\n    res = tuple(\n        tuple(a * b for a, b in zip(tup1, tup2))\n       \n        for tup1, tup2 in zip(test_tup1, test_tup2)\n    )\n    return res", "label": 1, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def index_multiplication(test_tup1, test_tup2):\n    res = tuple(\n        tuple(a * b2 for a, b2 in zip(tup1, tup2))\n       \n        for tup1, tup2 in zip(test_tup1, test_tup2)\n    )\n    return res", "label": 1, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def index_multiplication(test_tup1, test_tup2):\n    res = tuple(\n        tuple(a * b for a, b in zip(VAR_0, tup2))\n       \n        for VAR_0, tup2 in zip(test_tup1, test_tup2)\n    )\n    return res", "label": 1, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def index_multiplication(CQ23q9M96, test_tup2):\n    res = tuple(\n        tuple(a * b for a, b in zip(tup1, tup2))\n       \n        for tup1, tup2 in zip(CQ23q9M96, test_tup2)\n    )\n    return res", "label": 1, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_mul_div_variable", "transformed_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a / b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "label": 0, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 442, "dataset": "mbpp"},
{"original_code": "def index_multiplication(test_tup1, test_tup2):\n  \n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 442, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_dead_code_insert", "transformed_code": "def cube_nums(nums):\n    if False:\n        return cube_nums\n   \n    cube_nums = list(map(lambda x: x ** 3, nums))\n    return cube_nums", "label": 1, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_for_while_loop", "transformed_code": "def cube_nums(nums):\n   \n    cube_nums = list(map(lambda x: x ** 3, nums))\n    return cube_nums", "label": 1, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_operand_swap", "transformed_code": "def cube_nums(nums):\n   \n    cube_nums = list(map(lambda x: x ** 3, nums))\n    return cube_nums", "label": 1, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_rename_variable_cb", "transformed_code": "def cube_nums(nums):\n   \n    cube_nums = list(map(lambda x2: x2 ** 3, nums))\n    return cube_nums", "label": 1, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_rename_variable_naive", "transformed_code": "def cube_nums(VAR_0):\n   \n    cube_nums = list(map(lambda x: x ** 3, VAR_0))\n    return cube_nums", "label": 1, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_rename_variable_rn", "transformed_code": "def cube_nums(nums):\n   \n    cube_nums = list(map(lambda u: u ** 3, nums))\n    return cube_nums", "label": 1, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_mul_div_variable", "transformed_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x /* 3, nums))\n return cube_nums", "label": 0, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 444, "dataset": "mbpp"},
{"original_code": "def cube_nums(nums):\n \n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 444, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_dead_code_insert", "transformed_code": "def extract_string(str, l):\n    if False:\n        return result\n   \n    result = [e for e in str if len(e) == l]\n    return result", "label": 1, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_for_while_loop", "transformed_code": "def extract_string(str, l):\n   \n    result = [e for e in str if len(e) == l]\n    return result", "label": 1, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_operand_swap", "transformed_code": "def extract_string(str, l):\n   \n    result = [e for e in str if l == len(e)]\n    return result", "label": 1, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_rename_variable_cb", "transformed_code": "def extract_string(str, l):\n   \n    result = [l2 for l2 in str if len(l2) == l]\n    return result", "label": 1, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_rename_variable_naive", "transformed_code": "def extract_string(str, l):\n   \n    result = [VAR_0 for VAR_0 in str if len(VAR_0) == l]\n    return result", "label": 1, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_rename_variable_rn", "transformed_code": "def extract_string(str, l):\n   \n    result = [p for p in str if len(p) == l]\n    return result", "label": 1, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) != l] \n    return result", "label": 0, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 447, "dataset": "mbpp"},
{"original_code": "def extract_string(str, l):\n    \n    result = [e for e in str if len(e) == l] \n    return result", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 447, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_dead_code_insert", "transformed_code": "def remove_whitespaces(text1):\n    for _i_0 in range(0):\n        import re\n    import re\n   \n    return re.sub(r\"s+\", \"\", text1)", "label": 1, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_for_while_loop", "transformed_code": "def remove_whitespaces(text1):\n    import re\n   \n    return re.sub(r\"s+\", \"\", text1)", "label": 1, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_operand_swap", "transformed_code": "def remove_whitespaces(text1):\n    import re\n   \n    return re.sub(r\"s+\", \"\", text1)", "label": 1, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_rename_variable_cb", "transformed_code": "def remove_whitespaces(line):\n    import re\n   \n    return re.sub(r\"s+\", \"\", line)", "label": 1, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_rename_variable_naive", "transformed_code": "def remove_whitespaces(VAR_0):\n    import re\n   \n    return re.sub(r\"s+\", \"\", VAR_0)", "label": 1, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_rename_variable_rn", "transformed_code": "def remove_whitespaces(JJ88h):\n    import re\n   \n    return re.sub(r\"s+\", \"\", JJ88h)", "label": 1, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_add_sub_variable", "transformed_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s-', '',text1))", "label": 0, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 448, "dataset": "mbpp"},
{"original_code": "def remove_whitespaces(text1):\n  import re\n  \n  return (re.sub(r'\\s+', '',text1))", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 448, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_dead_code_insert", "transformed_code": "def loss_amount(actual_cost, sale_amount):\n    if sale_amount > actual_cost:\n        _i_5 = 0\n        if _i_5 < _i_5:\n            return None\n        amount = sale_amount - actual_cost\n       \n        return amount\n    else:\n        return None", "label": 1, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_for_while_loop", "transformed_code": "def loss_amount(actual_cost, sale_amount):\n    if sale_amount > actual_cost:\n        amount = sale_amount - actual_cost\n       \n        return amount\n    else:\n        return None", "label": 1, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_operand_swap", "transformed_code": "def loss_amount(actual_cost, sale_amount):\n    if actual_cost < sale_amount:\n        amount = sale_amount - actual_cost\n       \n        return amount\n    else:\n        return None", "label": 1, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_rename_variable_cb", "transformed_code": "def loss_amount(actual_cost, cost):\n    if cost > actual_cost:\n        amount = cost - actual_cost\n       \n        return amount\n    else:\n        return None", "label": 1, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_rename_variable_naive", "transformed_code": "def loss_amount(VAR_0, sale_amount):\n    if sale_amount > VAR_0:\n        amount = sale_amount - VAR_0\n       \n        return amount\n    else:\n        return None", "label": 1, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_rename_variable_rn", "transformed_code": "def loss_amount(actual_cost, V76y1K7q747):\n    if V76y1K7q747 > actual_cost:\n        amount = V76y1K7q747 - actual_cost\n       \n        return amount\n    else:\n        return None", "label": 1, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_sub_add_variable", "transformed_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount + actual_cost\n    return amount\n  else:\n    return None", "label": 0, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount < actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "label": 0, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 449, "dataset": "mbpp"},
{"original_code": "def loss_amount(actual_cost,sale_amount):\n   \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return None", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 449, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_dead_code_insert", "transformed_code": "def sumofFactors(n):\n    import math\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1):\n        count = 0\n        while False:\n            count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n           \n            count = count + 1\n            n = n // i\n            if i == 2 and count == 1:\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "label": 1, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_for_while_loop", "transformed_code": "def sumofFactors(n):\n    import math\n    if n % 2 != 0:\n        return 0\n    res = 1\n    i = 2\n    while i < (int)(math.sqrt(n)) + 1:\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n           \n            count = count + 1\n            n = n // i\n            if i == 2 and count == 1:\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n        i += 1\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "label": 1, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_operand_swap", "transformed_code": "def sumofFactors(n):\n    import math\n    if 0 != n % 2:\n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n           \n            count = count + 1\n            n = n // i\n            if i == 2 and count == 1:\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "label": 1, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def sumofFactors(i2):\n    import math\n    if i2 % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(i2)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while i2 % i == 0:\n           \n            count = count + 1\n            i2 = i2 // i\n            if i == 2 and count == 1:\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if i2 >= 2:\n        res = res * (1 + i2)\n    return res", "label": 1, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def sumofFactors(VAR_0):\n    import math\n    if VAR_0 % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(VAR_0)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while VAR_0 % i == 0:\n           \n            count = count + 1\n            VAR_0 = VAR_0 // i\n            if i == 2 and count == 1:\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if VAR_0 >= 2:\n        res = res * (1 + VAR_0)\n    return res", "label": 1, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def sumofFactors(i2):\n    import math\n    if i2 % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(i2)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while i2 % i == 0:\n           \n            count = count + 1\n            i2 = i2 // i\n            if i == 2 and count == 1:\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if i2 >= 2:\n        res = res * (1 + i2)\n    return res", "label": 1, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_add_sub_variable", "transformed_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) - 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_mul_div_variable", "transformed_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term / i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_div_mul_variable", "transformed_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n */ i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n <= 2) : \n        res = res * (1 + n) \n    return res ", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i != 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_exclamation_equalto_variable", "transformed_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 == 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_and_or_variable", "transformed_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 or count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def sumofFactors(n) :\n    import math \n     \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 450, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_dead_code_insert", "transformed_code": "def text_match_wordz(text):\n    import re\n    patterns = \"w*z.w*\"\n    _i_0 = 0\n    while _i_0 < _i_0:\n        import re\n   \n    if re.search(patterns, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"", "label": 1, "groups": 451, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_for_while_loop", "transformed_code": "def text_match_wordz(text):\n    import re\n    patterns = \"w*z.w*\"\n   \n    if re.search(patterns, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"", "label": 1, "groups": 451, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_operand_swap", "transformed_code": "def text_match_wordz(text):\n    import re\n    patterns = \"w*z.w*\"\n   \n    if re.search(patterns, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"", "label": 1, "groups": 451, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_rename_variable_naive", "transformed_code": "def text_match_wordz(VAR_0):\n    import re\n    patterns = \"w*z.w*\"\n   \n    if re.search(patterns, VAR_0):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"", "label": 1, "groups": 451, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_rename_variable_rn", "transformed_code": "def text_match_wordz(Yo89):\n    import re\n    patterns = \"w*z.w*\"\n   \n    if re.search(patterns, Yo89):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"", "label": 1, "groups": 451, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_mul_div_variable", "transformed_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w/z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "label": 0, "groups": 451, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 451, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 451, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 451, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 451, "dataset": "mbpp"},
{"original_code": "def text_match_wordz(text):\n        import re\n        \n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 451, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_dead_code_insert", "transformed_code": "def reverse_string_list(stringlist):\n    _i_2 = 0\n    while _i_2 > _i_2:\n        return result\n   \n    result = [x[::-1] for x in stringlist]\n    return result", "label": 1, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_for_while_loop", "transformed_code": "def reverse_string_list(stringlist):\n   \n    result = [x[::-1] for x in stringlist]\n    return result", "label": 1, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_operand_swap", "transformed_code": "def reverse_string_list(stringlist):\n   \n    result = [x[::-1] for x in stringlist]\n    return result", "label": 1, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_rename_variable_cb", "transformed_code": "def reverse_string_list(stringlist):\n   \n    result = [s[::-1] for s in stringlist]\n    return result", "label": 1, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_rename_variable_naive", "transformed_code": "def reverse_string_list(VAR_0):\n   \n    result = [x[::-1] for x in VAR_0]\n    return result", "label": 1, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_rename_variable_rn", "transformed_code": "def reverse_string_list(stringlist):\n   \n    result = [r[::-1] for r in stringlist]\n    return result", "label": 1, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_sub_add_variable", "transformed_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::+1] for x in stringlist]\n    return result", "label": 0, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 453, "dataset": "mbpp"},
{"original_code": "def reverse_string_list(stringlist):\n    \n    result = [x[::-1] for x in stringlist]\n    return result", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 453, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_dead_code_insert", "transformed_code": "def remove_uppercase(str1):\n    import re\n    for _i_1 in range(0):\n        import re\n   \n    remove_upper = lambda text: re.sub(\"[A-Z]\", \"\", text)\n    result = remove_upper(str1)\n    return result", "label": 1, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_for_while_loop", "transformed_code": "def remove_uppercase(str1):\n    import re\n   \n    remove_upper = lambda text: re.sub(\"[A-Z]\", \"\", text)\n    result = remove_upper(str1)\n    return result", "label": 1, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_operand_swap", "transformed_code": "def remove_uppercase(str1):\n    import re\n   \n    remove_upper = lambda text: re.sub(\"[A-Z]\", \"\", text)\n    result = remove_upper(str1)\n    return result", "label": 1, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_rename_variable_cb", "transformed_code": "def remove_uppercase(text2):\n    import re\n   \n    remove_upper = lambda text: re.sub(\"[A-Z]\", \"\", text)\n    result = remove_upper(text2)\n    return result", "label": 1, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_rename_variable_naive", "transformed_code": "def remove_uppercase(VAR_0):\n    import re\n   \n    remove_upper = lambda text: re.sub(\"[A-Z]\", \"\", text)\n    result = remove_upper(VAR_0)\n    return result", "label": 1, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_rename_variable_rn", "transformed_code": "def remove_uppercase(str1):\n    import re\n   \n    remove_upper = lambda t9M4: re.sub(\"[A-Z]\", \"\", t9M4)\n    result = remove_upper(str1)\n    return result", "label": 1, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_sub_add_variable", "transformed_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A+Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "label": 0, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 456, "dataset": "mbpp"},
{"original_code": "def remove_uppercase(str1):\n  import re\n  \n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\n  result =  remove_upper(str1)\n  return (result)", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 456, "dataset": "mbpp"},
{"original_code": "def Extract(lst):\n     \n    return [item[0] for item in lst] ", "transformation": "transformation_dead_code_insert", "transformed_code": "def Extract(lst):\n    while False:\n        return [item[0] for item in lst]\n   \nreturn [item[0] for item in lst]", "label": 1, "groups": 457, "dataset": "mbpp"},
{"original_code": "def Extract(lst):\n     \n    return [item[0] for item in lst] ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 457, "dataset": "mbpp"},
{"original_code": "def Extract(lst):\n     \n    return [item[0] for item in lst] ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 457, "dataset": "mbpp"},
{"original_code": "def Extract(lst):\n     \n    return [item[0] for item in lst] ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 457, "dataset": "mbpp"},
{"original_code": "def Extract(lst):\n     \n    return [item[0] for item in lst] ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 457, "dataset": "mbpp"},
{"original_code": "def Extract(lst):\n     \n    return [item[0] for item in lst] ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 457, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_dead_code_insert", "transformed_code": "def drop_empty(dict1):\n    while False:\n        return dict1\n   \n    dict1 = {key: value for (key, value) in dict1.items() if value is not None}\n    return dict1", "label": 1, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_for_while_loop", "transformed_code": "def drop_empty(dict1):\n   \n    dict1 = {key: value for (key, value) in dict1.items() if value is not None}\n    return dict1", "label": 1, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_operand_swap", "transformed_code": "def drop_empty(dict1):\n   \n    dict1 = {key: value for (key, value) in dict1.items() if value is not None}\n    return dict1", "label": 1, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_rename_variable_cb", "transformed_code": "def drop_empty(data):\n   \n    data = {key: value for (key, value) in data.items() if value is not None}\n    return data", "label": 1, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_rename_variable_naive", "transformed_code": "def drop_empty(VAR_0):\n   \n    VAR_0 = {key: value for (key, value) in VAR_0.items() if value is not None}\n    return VAR_0", "label": 1, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_rename_variable_rn", "transformed_code": "def drop_empty(h0059):\n   \n    h0059 = {key: value for (key, value) in h0059.items() if value is not None}\n    return h0059", "label": 1, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_isnot_is_variable", "transformed_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is None}\n  return dict1", "label": 0, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_is_isnot_variable", "transformed_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not not None}\n  return dict1", "label": 0, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 462, "dataset": "mbpp"},
{"original_code": "def drop_empty(dict1):\n  \n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 462, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_dead_code_insert", "transformed_code": "def decimal_to_Octal(deciNum):\n    octalNum = 0\n    _i_8 = 0\n    while _i_8 < _i_8:\n        countval = countval * 10\n    countval = 1\n    dNo = deciNum\n    while deciNum != 0:\n       \n        remainder = deciNum % 8\n        octalNum += remainder * countval\n        countval = countval * 10\n        deciNum //= 8\n    return octalNum", "label": 1, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_for_while_loop", "transformed_code": "def decimal_to_Octal(deciNum):\n    octalNum = 0\n    countval = 1\n    dNo = deciNum\n    while deciNum != 0:\n       \n        remainder = deciNum % 8\n        octalNum += remainder * countval\n        countval = countval * 10\n        deciNum //= 8\n    return octalNum", "label": 1, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_operand_swap", "transformed_code": "def decimal_to_Octal(deciNum):\n    octalNum = 0\n    countval = 1\n    dNo = deciNum\n    while 0 != deciNum:\n       \n        remainder = deciNum % 8\n        octalNum += remainder * countval\n        countval = countval * 10\n        deciNum //= 8\n    return octalNum", "label": 1, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_rename_variable_cb", "transformed_code": "def decimal_to_Octal(remainder2):\n    octalNum = 0\n    countval = 1\n    dNo = remainder2\n    while remainder2 != 0:\n       \n        remainder = remainder2 % 8\n        octalNum += remainder * countval\n        countval = countval * 10\n        remainder2 //= 8\n    return octalNum", "label": 1, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_rename_variable_naive", "transformed_code": "def decimal_to_Octal(VAR_0):\n    octalNum = 0\n    countval = 1\n    dNo = VAR_0\n    while VAR_0 != 0:\n       \n        remainder = VAR_0 % 8\n        octalNum += remainder * countval\n        countval = countval * 10\n        VAR_0 //= 8\n    return octalNum", "label": 1, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_rename_variable_rn", "transformed_code": "def decimal_to_Octal(F69w75e):\n    octalNum = 0\n    countval = 1\n    dNo = F69w75e\n    while F69w75e != 0:\n       \n        remainder = F69w75e % 8\n        octalNum += remainder * countval\n        countval = countval * 10\n        F69w75e //= 8\n    return octalNum", "label": 1, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_add_sub_variable", "transformed_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum-= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "label": 0, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_mul_div_variable", "transformed_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder/countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "label": 0, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_div_mul_variable", "transformed_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum */= 8; \n    return (octalNum)", "label": 0, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_exclamation_equalto_variable", "transformed_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum== 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "label": 0, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 464, "dataset": "mbpp"},
{"original_code": "def decimal_to_Octal(deciNum):\n    \n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8; \n    return (octalNum)", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 464, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_dead_code_insert", "transformed_code": "def max_product(arr, n):\n    _i_1 = 0\n    while _i_1 > _i_1:\n        return max(mpis)\n    mpis = [0] * (n)\n    for i in range(n):\n        mpis[i] = arr[i]\n    for i in range(1, n):\n       \n        for j in range(i):\n            if arr[i] > arr[j] and mpis[i] < (mpis[j] * arr[i]):\n                mpis[i] = mpis[j] * arr[i]\n    return max(mpis)", "label": 1, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_for_while_loop", "transformed_code": "def max_product(arr, n):\n    mpis = [0] * (n)\n    i = 0\n    while i < n:\n        mpis[i] = arr[i]\n        i += 1\n    for i in range(1, n):\n       \n        for j in range(i):\n            if arr[i] > arr[j] and mpis[i] < (mpis[j] * arr[i]):\n                mpis[i] = mpis[j] * arr[i]\n    return max(mpis)", "label": 1, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_operand_swap", "transformed_code": "def max_product(arr, n):\n    mpis = [0] * (n)\n    for i in range(n):\n        mpis[i] = arr[i]\n    for i in range(1, n):\n       \n        for j in range(i):\n            if arr[j] < arr[i] and mpis[i] < (mpis[j] * arr[i]):\n                mpis[i] = mpis[j] * arr[i]\n    return max(mpis)", "label": 1, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_rename_variable_cb", "transformed_code": "def max_product(arr, n):\n    mpis = [0] * (n)\n    for i2 in range(n):\n        mpis[i2] = arr[i2]\n    for i2 in range(1, n):\n       \n        for j in range(i2):\n            if arr[i2] > arr[j] and mpis[i2] < (mpis[j] * arr[i2]):\n                mpis[i2] = mpis[j] * arr[i2]\n    return max(mpis)", "label": 1, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_rename_variable_naive", "transformed_code": "def max_product(arr, n):\n    mpis = [0] * (n)\n    for VAR_0 in range(n):\n        mpis[VAR_0] = arr[VAR_0]\n    for VAR_0 in range(1, n):\n       \n        for j in range(VAR_0):\n            if arr[VAR_0] > arr[j] and mpis[VAR_0] < (mpis[j] * arr[VAR_0]):\n                mpis[VAR_0] = mpis[j] * arr[VAR_0]\n    return max(mpis)", "label": 1, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_rename_variable_rn", "transformed_code": "def max_product(arr, n):\n    mpis = [0] * (n)\n    for f in range(n):\n        mpis[f] = arr[f]\n    for f in range(1, n):\n       \n        for j in range(f):\n            if arr[f] > arr[j] and mpis[f] < (mpis[j] * arr[f]):\n                mpis[f] = mpis[j] * arr[f]\n    return max(mpis)", "label": 1, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_mul_div_variable", "transformed_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] / (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "label": 0, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] > (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "label": 0, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] < arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "label": 0, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_and_or_variable", "transformed_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] or\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "label": 0, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 465, "dataset": "mbpp"},
{"original_code": "def max_product(arr, n ):\n\t \n\tmpis =[0] * (n) \n\tfor i in range(n): \n\t\tmpis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \n\treturn max(mpis)", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 465, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def add_pairwise(test_tup):\n    for _i_2 in range(0):\n        return res\n   \n    res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n    return res", "label": 1, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_for_while_loop", "transformed_code": "def add_pairwise(test_tup):\n   \n    res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n    return res", "label": 1, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_operand_swap", "transformed_code": "def add_pairwise(test_tup):\n   \n    res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n    return res", "label": 1, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def add_pairwise(res2):\n   \n    res = tuple(i + j for i, j in zip(res2, res2[1:]))\n    return res", "label": 1, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def add_pairwise(VAR_0):\n   \n    res = tuple(i + j for i, j in zip(VAR_0, VAR_0[1:]))\n    return res", "label": 1, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def add_pairwise(Jd79g6g3):\n   \n    res = tuple(i + j for i, j in zip(Jd79g6g3, Jd79g6g3[1:]))\n    return res", "label": 1, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_add_sub_variable", "transformed_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i - j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "label": 0, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 467, "dataset": "mbpp"},
{"original_code": "def add_pairwise(test_tup):\n  \n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 467, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_dead_code_insert", "transformed_code": "def find_remainder(arr, lens, n):\n    mul = 1\n    for _i_5 in range(0):\n        mul = (mul * (arr[i] % n)) % n\n   \n    for i in range(lens):\n        mul = (mul * (arr[i] % n)) % n\n    return mul % n", "label": 1, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_for_while_loop", "transformed_code": "def find_remainder(arr, lens, n):\n    mul = 1\n   \n    i = 0\n    while i < lens:\n        mul = (mul * (arr[i] % n)) % n\n        i += 1\n    return mul % n", "label": 1, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_operand_swap", "transformed_code": "def find_remainder(arr, lens, n):\n    mul = 1\n   \n    for i in range(lens):\n        mul = (mul * (arr[i] % n)) % n\n    return mul % n", "label": 1, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def find_remainder(arr, lens, n):\n    n2 = 1\n   \n    for i in range(lens):\n        n2 = (n2 * (arr[i] % n)) % n\n    return n2 % n", "label": 1, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def find_remainder(arr, lens, VAR_0):\n    mul = 1\n   \n    for i in range(lens):\n        mul = (mul * (arr[i] % VAR_0)) % VAR_0\n    return mul % VAR_0", "label": 1, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def find_remainder(arr, lens, A):\n    mul = 1\n   \n    for i in range(lens):\n        mul = (mul * (arr[i] % A)) % A\n    return mul % A", "label": 1, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_mul_div_variable", "transformed_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul / (arr[i] % n)) % n \n    return mul % n ", "label": 0, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 468, "dataset": "mbpp"},
{"original_code": "def find_remainder(arr, lens, n):\n     \n    mul = 1\n    for i in range(lens):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 468, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_dead_code_insert", "transformed_code": "def get_max_occuring_char(str1):\n    ASCII_SIZE = 256\n    while False:\n        ctr = [0] * ASCII_SIZE\n    ctr = [0] * ASCII_SIZE\n    max = -1\n    ch = \"\"\n    for i in str1:\n       \n        ctr[ord(i)] += 1\n    for i in str1:\n        if max < ctr[ord(i)]:\n            max = ctr[ord(i)]\n            ch = i\n    return ch", "label": 1, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_for_while_loop", "transformed_code": "def get_max_occuring_char(str1):\n    ASCII_SIZE = 256\n    ctr = [0] * ASCII_SIZE\n    max = -1\n    ch = \"\"\n    _i_i = 0\n    while _i_i < len(str1):\n        i = str1[_i_i]\n       \n        ctr[ord(i)] += 1\n        _i_i += 1\n    for i in str1:\n        if max < ctr[ord(i)]:\n            max = ctr[ord(i)]\n            ch = i\n    return ch", "label": 1, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_operand_swap", "transformed_code": "def get_max_occuring_char(str1):\n    ASCII_SIZE = 256\n    ctr = [0] * ASCII_SIZE\n    max = -1\n    ch = \"\"\n    for i in str1:\n       \n        ctr[ord(i)] += 1\n    for i in str1:\n        if ctr[ord(i)] > max:\n            max = ctr[ord(i)]\n            ch = i\n    return ch", "label": 1, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_rename_variable_cb", "transformed_code": "def get_max_occuring_char(str1):\n    ASCII_SIZE = 256\n    ctr = [0] * ASCII_SIZE\n    max = -1\n    ch = \"\"\n    for max2 in str1:\n       \n        ctr[ord(max2)] += 1\n    for max2 in str1:\n        if max < ctr[ord(max2)]:\n            max = ctr[ord(max2)]\n            ch = max2\n    return ch", "label": 1, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_rename_variable_naive", "transformed_code": "def get_max_occuring_char(str1):\n    ASCII_SIZE = 256\n    ctr = [0] * ASCII_SIZE\n    max = -1\n    ch = \"\"\n    for VAR_0 in str1:\n       \n        ctr[ord(VAR_0)] += 1\n    for VAR_0 in str1:\n        if max < ctr[ord(VAR_0)]:\n            max = ctr[ord(VAR_0)]\n            ch = VAR_0\n    return ch", "label": 1, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_rename_variable_rn", "transformed_code": "def get_max_occuring_char(str1):\n    ASCII_SIZE = 256\n    ctr = [0] * ASCII_SIZE\n    max = -1\n    ch = \"\"\n    for G in str1:\n       \n        ctr[ord(G)] += 1\n    for G in str1:\n        if max < ctr[ord(G)]:\n            max = ctr[ord(G)]\n            ch = G\n    return ch", "label": 1, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_add_sub_variable", "transformed_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]-=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "label": 0, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_sub_add_variable", "transformed_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = +1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "label": 0, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_mul_div_variable", "transformed_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] / ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "label": 0, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max > ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "label": 0, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 477, "dataset": "mbpp"},
{"original_code": "def get_max_occuring_char(str1):\n  \n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 477, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_dead_code_insert", "transformed_code": "def is_subset_sum(set, n, sum):\n    if sum == 0:\n        return True\n    _i_2 = 0\n    while _i_2 > _i_2:\n        return False\n    if n == 0:\n       \n        return False\n    if set[n - 1] > sum:\n        return is_subset_sum(set, n - 1, sum)\n    return is_subset_sum(set, n - 1, sum) or is_subset_sum(set, n - 1, sum - set[n - 1])", "label": 1, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_for_while_loop", "transformed_code": "def is_subset_sum(set, n, sum):\n    if sum == 0:\n        return True\n    if n == 0:\n       \n        return False\n    if set[n - 1] > sum:\n        return is_subset_sum(set, n - 1, sum)\n    return is_subset_sum(set, n - 1, sum) or is_subset_sum(set, n - 1, sum - set[n - 1])", "label": 1, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_operand_swap", "transformed_code": "def is_subset_sum(set, n, sum):\n    if 0 == sum:\n        return True\n    if n == 0:\n       \n        return False\n    if set[n - 1] > sum:\n        return is_subset_sum(set, n - 1, sum)\n    return is_subset_sum(set, n - 1, sum) or is_subset_sum(set, n - 1, sum - set[n - 1])", "label": 1, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_rename_variable_cb", "transformed_code": "def is_subset_sum(set, i, sum):\n    if sum == 0:\n        return True\n    if i == 0:\n       \n        return False\n    if set[i - 1] > sum:\n        return is_subset_sum(set, i - 1, sum)\n    return is_subset_sum(set, i - 1, sum) or is_subset_sum(set, i - 1, sum - set[i - 1])", "label": 1, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_rename_variable_naive", "transformed_code": "def is_subset_sum(set, VAR_0, sum):\n    if sum == 0:\n        return True\n    if VAR_0 == 0:\n       \n        return False\n    if set[VAR_0 - 1] > sum:\n        return is_subset_sum(set, VAR_0 - 1, sum)\n    return is_subset_sum(set, VAR_0 - 1, sum) or is_subset_sum(\n        set, VAR_0 - 1, sum - set[VAR_0 - 1]\n    )", "label": 1, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_rename_variable_rn", "transformed_code": "def is_subset_sum(set, P, sum):\n    if sum == 0:\n        return True\n    if P == 0:\n       \n        return False\n    if set[P - 1] > sum:\n        return is_subset_sum(set, P - 1, sum)\n    return is_subset_sum(set, P - 1, sum) or is_subset_sum(set, P - 1, sum - set[P - 1])", "label": 1, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_sub_add_variable", "transformed_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n + 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] < sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum != 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_true_false_variable", "transformed_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn False\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_false_true_variable", "transformed_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn True\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_or_and_variable", "transformed_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) and is_subset_sum(set, n-1, sum-set[n-1])", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def is_subset_sum(set, n, sum):\n\t\n\tif (sum == 0):\n\t\treturn True\n\tif (n == 0):\n\t\treturn False\n\tif (set[n - 1] > sum):\n\t\treturn is_subset_sum(set, n - 1, sum)\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 478, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_dead_code_insert", "transformed_code": "def match(text):\n    import re\n    pattern = \"[A-Z]+[a-z]+$\"\n    _i_2 = 0\n    if _i_2 > _i_2:\n        return \"Yes\"\n   \n    if re.search(pattern, text):\n        return \"Yes\"\n    else:\n        return \"No\"", "label": 1, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_for_while_loop", "transformed_code": "def match(text):\n    import re\n    pattern = \"[A-Z]+[a-z]+$\"\n   \n    if re.search(pattern, text):\n        return \"Yes\"\n    else:\n        return \"No\"", "label": 1, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_operand_swap", "transformed_code": "def match(text):\n    import re\n    pattern = \"[A-Z]+[a-z]+$\"\n   \n    if re.search(pattern, text):\n        return \"Yes\"\n    else:\n        return \"No\"", "label": 1, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def match(text):\n    import re\n    pattern2 = \"[A-Z]+[a-z]+$\"\n   \n    if re.search(pattern2, text):\n        return \"Yes\"\n    else:\n        return \"No\"", "label": 1, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def match(VAR_0):\n    import re\n    pattern = \"[A-Z]+[a-z]+$\"\n   \n    if re.search(pattern, VAR_0):\n        return \"Yes\"\n    else:\n        return \"No\"", "label": 1, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def match(Y1t1):\n    import re\n    pattern = \"[A-Z]+[a-z]+$\"\n   \n    if re.search(pattern, Y1t1):\n        return \"Yes\"\n    else:\n        return \"No\"", "label": 1, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_add_sub_variable", "transformed_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]-[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "label": 0, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_sub_add_variable", "transformed_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A+Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "label": 0, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 479, "dataset": "mbpp"},
{"original_code": "def match(text):\n\t\timport re \n\t\t \n\t\tpattern = '[A-Z]+[a-z]+$'\n\t\tif re.search(pattern, text): \n\t\t\t\treturn('Yes') \n\t\telse: \n\t\t\t\treturn('No') ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 479, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def remove_matching_tuple(test_list1, test_list2):\n    _i_0 = 0\n    while _i_0 > _i_0:\n        return res\n   \n    res = [sub for sub in test_list1 if sub not in test_list2]\n    return res", "label": 1, "groups": 481, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_for_while_loop", "transformed_code": "def remove_matching_tuple(test_list1, test_list2):\n   \n    res = [sub for sub in test_list1 if sub not in test_list2]\n    return res", "label": 1, "groups": 481, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_operand_swap", "transformed_code": "def remove_matching_tuple(test_list1, test_list2):\n   \n    res = [sub for sub in test_list1 if sub not in test_list2]\n    return res", "label": 1, "groups": 481, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def remove_matching_tuple(test_list1, test_list2):\n   \n    res = [test for test in test_list1 if test not in test_list2]\n    return res", "label": 1, "groups": 481, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def remove_matching_tuple(test_list1, test_list2):\n   \n    res = [VAR_0 for VAR_0 in test_list1 if VAR_0 not in test_list2]\n    return res", "label": 1, "groups": 481, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def remove_matching_tuple(test_list1, test_list2):\n   \n    res = [qyj for qyj in test_list1 if qyj not in test_list2]\n    return res", "label": 1, "groups": 481, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 481, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 481, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 481, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 481, "dataset": "mbpp"},
{"original_code": "def remove_matching_tuple(test_list1, test_list2):\n  \n  res = [sub for sub in test_list1 if sub not in test_list2]\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 481, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_dead_code_insert", "transformed_code": "def largest_palindrome(A, n):\n    def is_palindrome(n):\n        divisor = 1\n        while n / divisor >= 10:\n            divisor *= 10\n        while n != 0:\n            leading = n // divisor\n            if False:\n                n = (n % divisor) // 10\n            trailing = n % 10\n            if leading != trailing:\n                return False\n               \n            n = (n % divisor) // 10\n            divisor = divisor // 100\n        return True\n    A.sort()\n    for i in range(n - 1, -1, -1):\n        if is_palindrome(A[i]):\n            return A[i]\n    return -1", "label": 1, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_for_while_loop", "transformed_code": "def largest_palindrome(A, n):\n    def is_palindrome(n):\n        divisor = 1\n        while n / divisor >= 10:\n            divisor *= 10\n        while n != 0:\n            leading = n // divisor\n            trailing = n % 10\n            if leading != trailing:\n                return False\n               \n            n = (n % divisor) // 10\n            divisor = divisor // 100\n        return True\n    A.sort()\n    i = n - 1\n    while i > -1:\n        if is_palindrome(A[i]):\n            return A[i]\n        i -= 1\n    return -1", "label": 1, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_operand_swap", "transformed_code": "def largest_palindrome(A, n):\n    def is_palindrome(n):\n        divisor = 1\n        while 10 <= n / divisor:\n            divisor *= 10\n        while n != 0:\n            leading = n // divisor\n            trailing = n % 10\n            if leading != trailing:\n                return False\n               \n            n = (n % divisor) // 10\n            divisor = divisor // 100\n        return True\n    A.sort()\n    for i in range(n - 1, -1, -1):\n        if is_palindrome(A[i]):\n            return A[i]\n    return -1", "label": 1, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_rename_variable_cb", "transformed_code": "def largest_palindrome(A, g):\n    def is_palindrome(g):\n        divisor = 1\n        while g / divisor >= 10:\n            divisor *= 10\n        while g != 0:\n            leading = g // divisor\n            trailing = g % 10\n            if leading != trailing:\n                return False\n               \n            g = (g % divisor) // 10\n            divisor = divisor // 100\n        return True\n    A.sort()\n    for i in range(g - 1, -1, -1):\n        if is_palindrome(A[i]):\n            return A[i]\n    return -1", "label": 1, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_rename_variable_naive", "transformed_code": "def largest_palindrome(A, VAR_0):\n    def is_palindrome(VAR_0):\n        divisor = 1\n        while VAR_0 / divisor >= 10:\n            divisor *= 10\n        while VAR_0 != 0:\n            leading = VAR_0 // divisor\n            trailing = VAR_0 % 10\n            if leading != trailing:\n                return False\n               \n            VAR_0 = (VAR_0 % divisor) // 10\n            divisor = divisor // 100\n        return True\n    A.sort()\n    for i in range(VAR_0 - 1, -1, -1):\n        if is_palindrome(A[i]):\n            return A[i]\n    return -1", "label": 1, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_rename_variable_rn", "transformed_code": "def largest_palindrome(A, A2):\n    def is_palindrome(A2):\n        divisor = 1\n        while A2 / divisor >= 10:\n            divisor *= 10\n        while A2 != 0:\n            leading = A2 // divisor\n            trailing = A2 % 10\n            if leading != trailing:\n                return False\n               \n            A2 = (A2 % divisor) // 10\n            divisor = divisor // 100\n        return True\n    A.sort()\n    for i in range(A2 - 1, -1, -1):\n        if is_palindrome(A[i]):\n            return A[i]\n    return -1", "label": 1, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_sub_add_variable", "transformed_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n + 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_mul_div_variable", "transformed_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor /= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_div_mul_variable", "transformed_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n * divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor <= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_exclamation_equalto_variable", "transformed_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n == 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_true_false_variable", "transformed_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn False\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_false_true_variable", "transformed_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn True\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def largest_palindrome(A, n) :\n\tdef is_palindrome(n) : \n\t\tdivisor = 1\n\t\twhile (n / divisor >= 10) : \n\t\t\tdivisor *= 10\n\t\twhile (n != 0) : \n\t\t\tleading = n // divisor \n\t\t\ttrailing = n % 10\n\t\t\tif (leading != trailing) : \n\t\t\t\treturn False\n\t\t\tn = (n % divisor) // 10\n\t\t\tdivisor = divisor // 100\n\t\treturn True\n\t \n\tA.sort() \n\tfor i in range(n - 1, -1, -1) : \n\t\tif (is_palindrome(A[i])) : \n\t\t\treturn A[i] \n\treturn -1", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 482, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def binomial_probability(n, k, p):\n    def nCr(n, r):\n        if r > n / 2:\n            _i_8 = 0\n            while _i_8 < _i_8:\n                answer = 1\n            r = n - r\n        answer = 1\n        for i in range(1, r + 1):\n           \n            answer *= n - r + i\n            answer /= i\n        return answer\n    return nCr(n, k) * pow(p, k) * pow(1 - p, n - k)", "label": 1, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_for_while_loop", "transformed_code": "def binomial_probability(n, k, p):\n    def nCr(n, r):\n        if r > n / 2:\n            r = n - r\n        answer = 1\n        i = 1\n        while i < r + 1:\n           \n            answer *= n - r + i\n            answer /= i\n            i += 1\n        return answer\n    return nCr(n, k) * pow(p, k) * pow(1 - p, n - k)", "label": 1, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_operand_swap", "transformed_code": "def binomial_probability(n, k, p):\n    def nCr(n, r):\n        if n / 2 < r:\n            r = n - r\n        answer = 1\n        for i in range(1, r + 1):\n           \n            answer *= n - r + i\n            answer /= i\n        return answer\n    return nCr(n, k) * pow(p, k) * pow(1 - p, n - k)", "label": 1, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def binomial_probability(p2, k, p):\n    def nCr(p2, r):\n        if r > p2 / 2:\n            r = p2 - r\n        answer = 1\n        for i in range(1, r + 1):\n           \n            answer *= p2 - r + i\n            answer /= i\n        return answer\n    return nCr(p2, k) * pow(p, k) * pow(1 - p, p2 - k)", "label": 1, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def binomial_probability(VAR_0, k, p):\n    def nCr(VAR_0, r):\n        if r > VAR_0 / 2:\n            r = VAR_0 - r\n        answer = 1\n        for i in range(1, r + 1):\n           \n            answer *= VAR_0 - r + i\n            answer /= i\n        return answer\n    return nCr(VAR_0, k) * pow(p, k) * pow(1 - p, VAR_0 - k)", "label": 1, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def binomial_probability(k2, k, p):\n    def nCr(k2, r):\n        if r > k2 / 2:\n            r = k2 - r\n        answer = 1\n        for i in range(1, r + 1):\n           \n            answer *= k2 - r + i\n            answer /= i\n        return answer\n    return nCr(k2, k) * pow(p, k) * pow(1 - p, k2 - k)", "label": 1, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_add_sub_variable", "transformed_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r - 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "label": 0, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_sub_add_variable", "transformed_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n + r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "label": 0, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_mul_div_variable", "transformed_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer /= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "label": 0, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_div_mul_variable", "transformed_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n * 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "label": 0, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r < n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "label": 0, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 483, "dataset": "mbpp"},
{"original_code": "def binomial_probability(n, k, p):\n\tdef nCr(n, r): \n\t\tif (r > n / 2): \n\t\t\tr = n - r \n\t\tanswer = 1 \n\t\tfor i in range(1, r + 1): \n\t\t\tanswer *= (n - r + i) \n\t\t\tanswer /= i \n\t\treturn answer \n\t \n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 483, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_dead_code_insert", "transformed_code": "def area_pentagon(a):\n    import math\n    while False:\n        import math\n   \n    area = (math.sqrt(5 * (5 + 2 * math.sqrt(5))) * pow(a, 2)) / 4.0\n    return area", "label": 1, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_for_while_loop", "transformed_code": "def area_pentagon(a):\n    import math\n   \n    area = (math.sqrt(5 * (5 + 2 * math.sqrt(5))) * pow(a, 2)) / 4.0\n    return area", "label": 1, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_operand_swap", "transformed_code": "def area_pentagon(a):\n    import math\n   \n    area = (math.sqrt(5 * (5 + 2 * math.sqrt(5))) * pow(a, 2)) / 4.0\n    return area", "label": 1, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_rename_variable_naive", "transformed_code": "def area_pentagon(VAR_0):\n    import math\n   \n    area = (math.sqrt(5 * (5 + 2 * math.sqrt(5))) * pow(VAR_0, 2)) / 4.0\n    return area", "label": 1, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_rename_variable_rn", "transformed_code": "def area_pentagon(a):\n    import math\n   \n    D531 = (math.sqrt(5 * (5 + 2 * math.sqrt(5))) * pow(a, 2)) / 4.0\n    return D531", "label": 1, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_add_sub_variable", "transformed_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5-2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "label": 0, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_mul_div_variable", "transformed_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5/(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "label": 0, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_div_mul_variable", "transformed_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))*4.0\n  return area", "label": 0, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 485, "dataset": "mbpp"},
{"original_code": "def area_pentagon(a):\n  import math\n  \n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\n  return area", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 485, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_dead_code_insert", "transformed_code": "def frequency_Of_Largest(n, arr):\n    mn = arr[0]\n    _i_5 = 0\n    while _i_5 > _i_5:\n        mn = arr[0]\n    freq = 1\n    for i in range(1, n):\n        if arr[i] > mn:\n           \n            mn = arr[i]\n            freq = 1\n        elif arr[i] == mn:\n            freq += 1\n    return freq", "label": 1, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_for_while_loop", "transformed_code": "def frequency_Of_Largest(n, arr):\n    mn = arr[0]\n    freq = 1\n    i = 1\n    while i < n:\n        if arr[i] > mn:\n           \n            mn = arr[i]\n            freq = 1\n        elif arr[i] == mn:\n            freq += 1\n        i += 1\n    return freq", "label": 1, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_operand_swap", "transformed_code": "def frequency_Of_Largest(n, arr):\n    mn = arr[0]\n    freq = 1\n    for i in range(1, n):\n        if mn < arr[i]:\n           \n            mn = arr[i]\n            freq = 1\n        elif arr[i] == mn:\n            freq += 1\n    return freq", "label": 1, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def frequency_Of_Largest(n, n2):\n    mn = n2[0]\n    freq = 1\n    for i in range(1, n):\n        if n2[i] > mn:\n           \n            mn = n2[i]\n            freq = 1\n        elif n2[i] == mn:\n            freq += 1\n    return freq", "label": 1, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def frequency_Of_Largest(n, VAR_0):\n    mn = VAR_0[0]\n    freq = 1\n    for i in range(1, n):\n        if VAR_0[i] > mn:\n           \n            mn = VAR_0[i]\n            freq = 1\n        elif VAR_0[i] == mn:\n            freq += 1\n    return freq", "label": 1, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def frequency_Of_Largest(n, S70):\n    mn = S70[0]\n    freq = 1\n    for i in range(1, n):\n        if S70[i] > mn:\n           \n            mn = S70[i]\n            freq = 1\n        elif S70[i] == mn:\n            freq += 1\n    return freq", "label": 1, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_add_sub_variable", "transformed_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq -= 1\n    return freq ", "label": 0, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] <mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "label": 0, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] != mn): \n            freq += 1\n    return freq ", "label": 0, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 486, "dataset": "mbpp"},
{"original_code": "def frequency_Of_Largest(n,arr):\n     \n    mn = arr[0] \n    freq = 1\n    for i in range(1,n): \n        if (arr[i] >mn): \n            mn = arr[i] \n            freq = 1\n        elif (arr[i] == mn): \n            freq += 1\n    return freq ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 486, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_dead_code_insert", "transformed_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    if False:\n        origy = starty\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n           \n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y),\n            ]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 1, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_for_while_loop", "transformed_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n           \n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y),\n            ]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 1, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_operand_swap", "transformed_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while endy > starty:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n           \n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y),\n            ]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 1, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_rename_variable_cb", "transformed_code": "def calculate_polygons(x, starty, endx, endy, radius):\n    import math\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    x = x - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = x\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            x = origx + xoffset\n        else:\n            x = origx\n        while x < endx:\n            p1x = x\n           \n            p1y = starty + p\n            p2x = x\n            p2y = starty + (3 * p)\n            p3x = x + b\n            p3y = starty + h\n            p4x = x + w\n            p4y = starty + (3 * p)\n            p5x = x + w\n            p5y = starty + p\n            p6x = x + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y),\n            ]\n            polygons.append(poly)\n            counter += 1\n            x += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 1, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_rename_variable_naive", "transformed_code": "def calculate_polygons(VAR_0, starty, endx, endy, radius):\n    import math\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    VAR_0 = VAR_0 - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = VAR_0\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            VAR_0 = origx + xoffset\n        else:\n            VAR_0 = origx\n        while VAR_0 < endx:\n            p1x = VAR_0\n           \n            p1y = starty + p\n            p2x = VAR_0\n            p2y = starty + (3 * p)\n            p3x = VAR_0 + b\n            p3y = starty + h\n            p4x = VAR_0 + w\n            p4y = starty + (3 * p)\n            p5x = VAR_0 + w\n            p5y = starty + p\n            p6x = VAR_0 + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y),\n            ]\n            polygons.append(poly)\n            counter += 1\n            VAR_0 += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 1, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_rename_variable_rn", "transformed_code": "def calculate_polygons(oY7g44, starty, endx, endy, radius):\n    import math\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    oY7g44 = oY7g44 - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = oY7g44\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            oY7g44 = origx + xoffset\n        else:\n            oY7g44 = origx\n        while oY7g44 < endx:\n            p1x = oY7g44\n           \n            p1y = starty + p\n            p2x = oY7g44\n            p2y = starty + (3 * p)\n            p3x = oY7g44 + b\n            p3y = starty + h\n            p4x = oY7g44 + w\n            p4y = starty + (3 * p)\n            p5x = oY7g44 + w\n            p5y = starty + p\n            p6x = oY7g44 + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y),\n            ]\n            polygons.append(poly)\n            counter += 1\n            oY7g44 += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 1, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_add_sub_variable", "transformed_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx - w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_sub_add_variable", "transformed_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx + w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_mul_div_variable", "transformed_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 / radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_div_mul_variable", "transformed_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi * 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty > endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 != 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    import math\n    \n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\n                (p1x, p1y),\n                (p2x, p2y),\n                (p3x, p3y),\n                (p4x, p4y),\n                (p5x, p5y),\n                (p6x, p6y),\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 490, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_dead_code_insert", "transformed_code": "def heap_queue_smallest(nums, n):\n    for _i_9 in range(0):\n        return smallest_nums\n    import heapq as hq\n   \n    smallest_nums = hq.nsmallest(n, nums)\n    return smallest_nums", "label": 1, "groups": 493, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_for_while_loop", "transformed_code": "def heap_queue_smallest(nums, n):\n    import heapq as hq\n   \n    smallest_nums = hq.nsmallest(n, nums)\n    return smallest_nums", "label": 1, "groups": 493, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_operand_swap", "transformed_code": "def heap_queue_smallest(nums, n):\n    import heapq as hq\n   \n    smallest_nums = hq.nsmallest(n, nums)\n    return smallest_nums", "label": 1, "groups": 493, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_rename_variable_cb", "transformed_code": "def heap_queue_smallest(nums, n):\n    import heapq as hq\n   \n    it = hq.nsmallest(n, nums)\n    return it", "label": 1, "groups": 493, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_rename_variable_naive", "transformed_code": "def heap_queue_smallest(nums, VAR_0):\n    import heapq as hq\n   \n    smallest_nums = hq.nsmallest(VAR_0, nums)\n    return smallest_nums", "label": 1, "groups": 493, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_rename_variable_rn", "transformed_code": "def heap_queue_smallest(nums, y):\n    import heapq as hq\n   \n    smallest_nums = hq.nsmallest(y, nums)\n    return smallest_nums", "label": 1, "groups": 493, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 493, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 493, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 493, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 493, "dataset": "mbpp"},
{"original_code": "def heap_queue_smallest(nums,n):\n  import heapq as hq\n  \n  smallest_nums = hq.nsmallest(n, nums)\n  return smallest_nums", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 493, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_dead_code_insert", "transformed_code": "def surfacearea_cone(r, h):\n    import math\n    _i_4 = 0\n    while _i_4 > _i_4:\n        SA = math.pi * r * (r + l)\n   \n    l = math.sqrt(r * r + h * h)\n    SA = math.pi * r * (r + l)\n    return SA", "label": 1, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_for_while_loop", "transformed_code": "def surfacearea_cone(r, h):\n    import math\n   \n    l = math.sqrt(r * r + h * h)\n    SA = math.pi * r * (r + l)\n    return SA", "label": 1, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_operand_swap", "transformed_code": "def surfacearea_cone(r, h):\n    import math\n   \n    l = math.sqrt(r * r + h * h)\n    SA = math.pi * r * (r + l)\n    return SA", "label": 1, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_rename_variable_cb", "transformed_code": "def surfacearea_cone(p, h):\n    import math\n   \n    l = math.sqrt(p * p + h * h)\n    SA = math.pi * p * (p + l)\n    return SA", "label": 1, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_rename_variable_naive", "transformed_code": "def surfacearea_cone(VAR_0, h):\n    import math\n   \n    l = math.sqrt(VAR_0 * VAR_0 + h * h)\n    SA = math.pi * VAR_0 * (VAR_0 + l)\n    return SA", "label": 1, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_rename_variable_rn", "transformed_code": "def surfacearea_cone(c, h):\n    import math\n   \n    l = math.sqrt(c * c + h * h)\n    SA = math.pi * c * (c + l)\n    return SA", "label": 1, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_add_sub_variable", "transformed_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r - h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "label": 0, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_mul_div_variable", "transformed_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r / r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "label": 0, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 494, "dataset": "mbpp"},
{"original_code": "def surfacearea_cone(r,h):\n  import math\n  \n  l = math.sqrt(r * r + h * h)\n  SA = math.pi * r * (r + l)\n  return SA", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 494, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_dead_code_insert", "transformed_code": "def gcd(x, y):\n    gcd = 1\n    if x % y == 0:\n        _i_2 = 0\n        while _i_2 > _i_2:\n            break\n        return y\n       \n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break\n    return gcd", "label": 1, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_for_while_loop", "transformed_code": "def gcd(x, y):\n    gcd = 1\n    if x % y == 0:\n        return y\n       \n    k = int(y / 2)\n    while k > 0:\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break\n        k -= 1\n    return gcd", "label": 1, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_operand_swap", "transformed_code": "def gcd(x, y):\n    gcd = 1\n    if 0 == x % y:\n        return y\n       \n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break\n    return gcd", "label": 1, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_rename_variable_cb", "transformed_code": "def gcd(x, y2):\n    gcd = 1\n    if x % y2 == 0:\n        return y2\n       \n    for k in range(int(y2 / 2), 0, -1):\n        if x % k == 0 and y2 % k == 0:\n            gcd = k\n            break\n    return gcd", "label": 1, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_rename_variable_naive", "transformed_code": "def gcd(x, VAR_0):\n    gcd = 1\n    if x % VAR_0 == 0:\n        return VAR_0\n       \n    for k in range(int(VAR_0 / 2), 0, -1):\n        if x % k == 0 and VAR_0 % k == 0:\n            gcd = k\n            break\n    return gcd", "label": 1, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_rename_variable_rn", "transformed_code": "def gcd(x, C):\n    gcd = 1\n    if x % C == 0:\n        return C\n       \n    for k in range(int(C / 2), 0, -1):\n        if x % k == 0 and C % k == 0:\n            gcd = k\n            break\n    return gcd", "label": 1, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_sub_add_variable", "transformed_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, +1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "label": 0, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_div_mul_variable", "transformed_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y * 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "label": 0, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y != 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "label": 0, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_and_or_variable", "transformed_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 or y % k == 0:\n            gcd = k\n            break  \n    return gcd", "label": 0, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 495, "dataset": "mbpp"},
{"original_code": "def gcd(x, y):\n    \n    gcd = 1\n    if x % y == 0:\n        return y\n    for k in range(int(y / 2), 0, -1):\n        if x % k == 0 and y % k == 0:\n            gcd = k\n            break  \n    return gcd", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 495, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def concatenate_elements(list):\n    _i_9 = 0\n    if _i_9 < _i_9:\n        return ans\n    ans = \" \"\n   \n    for i in list:\n        ans = ans + \" \" + i\n    return ans", "label": 1, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_for_while_loop", "transformed_code": "def concatenate_elements(list):\n    ans = \" \"\n   \n    _i_i = 0\n    while _i_i < len(list):\n        i = list[_i_i]\n        ans = ans + \" \" + i\n        _i_i += 1\n    return ans", "label": 1, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_operand_swap", "transformed_code": "def concatenate_elements(list):\n    ans = \" \"\n   \n    for i in list:\n        ans = ans + \" \" + i\n    return ans", "label": 1, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def concatenate_elements(list):\n    prefix = \" \"\n   \n    for i in list:\n        prefix = prefix + \" \" + i\n    return prefix", "label": 1, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def concatenate_elements(list):\n    VAR_0 = \" \"\n   \n    for i in list:\n        VAR_0 = VAR_0 + \" \" + i\n    return VAR_0", "label": 1, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def concatenate_elements(list):\n    aWZ = \" \"\n   \n    for i in list:\n        aWZ = aWZ + \" \" + i\n    return aWZ", "label": 1, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_add_sub_variable", "transformed_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans- ' '+i\n  return (ans) ", "label": 0, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 497, "dataset": "mbpp"},
{"original_code": "def concatenate_elements(list):\n  \n  ans = ' '\n  for i in list:\n    ans = ans+ ' '+i\n  return (ans) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 497, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_dead_code_insert", "transformed_code": "def sum_Of_Series(n):\n    sum = 0\n    _i_5 = 0\n    if _i_5 > _i_5:\n        sum = 0\n   \n    for i in range(1, n + 1):\n        sum += i * i * i\n    return sum", "label": 1, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_for_while_loop", "transformed_code": "def sum_Of_Series(n):\n    sum = 0\n   \n    i = 1\n    while i < n + 1:\n        sum += i * i * i\n        i += 1\n    return sum", "label": 1, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_operand_swap", "transformed_code": "def sum_Of_Series(n):\n    sum = 0\n   \n    for i in range(1, n + 1):\n        sum += i * i * i\n    return sum", "label": 1, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_rename_variable_cb", "transformed_code": "def sum_Of_Series(n):\n    sum = 0\n   \n    for n2 in range(1, n + 1):\n        sum += n2 * n2 * n2\n    return sum", "label": 1, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_rename_variable_naive", "transformed_code": "def sum_Of_Series(n):\n    sum = 0\n   \n    for VAR_0 in range(1, n + 1):\n        sum += VAR_0 * VAR_0 * VAR_0\n    return sum", "label": 1, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_rename_variable_rn", "transformed_code": "def sum_Of_Series(n):\n    sum = 0\n   \n    for R in range(1, n + 1):\n        sum += R * R * R\n    return sum", "label": 1, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_add_sub_variable", "transformed_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n - 1): \n        sum += i * i*i       \n    return sum", "label": 0, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_mul_div_variable", "transformed_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i / i*i       \n    return sum", "label": 0, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 501, "dataset": "mbpp"},
{"original_code": "def sum_Of_Series(n):\n     \n    sum = 0\n    for i in range(1,n + 1): \n        sum += i * i*i       \n    return sum", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 501, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_dead_code_insert", "transformed_code": "def average_Odd(n):\n    if n % 2 == 0:\n        return \"Invalid Input\"\n        return -1\n    sm = 0\n    _i_6 = 0\n    while _i_6 > _i_6:\n        return \"Invalid Input\"\n   \n    count = 0\n    while n >= 1:\n        count = count + 1\n        sm = sm + n\n        n = n - 2\n    return sm // count", "label": 1, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_for_while_loop", "transformed_code": "def average_Odd(n):\n    if n % 2 == 0:\n        return \"Invalid Input\"\n        return -1\n    sm = 0\n   \n    count = 0\n    while n >= 1:\n        count = count + 1\n        sm = sm + n\n        n = n - 2\n    return sm // count", "label": 1, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_operand_swap", "transformed_code": "def average_Odd(n):\n    if 0 == n % 2:\n        return \"Invalid Input\"\n        return -1\n    sm = 0\n   \n    count = 0\n    while n >= 1:\n        count = count + 1\n        sm = sm + n\n        n = n - 2\n    return sm // count", "label": 1, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def average_Odd(t):\n    if t % 2 == 0:\n        return \"Invalid Input\"\n        return -1\n    sm = 0\n   \n    count = 0\n    while t >= 1:\n        count = count + 1\n        sm = sm + t\n        t = t - 2\n    return sm // count", "label": 1, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def average_Odd(VAR_0):\n    if VAR_0 % 2 == 0:\n        return \"Invalid Input\"\n        return -1\n    sm = 0\n   \n    count = 0\n    while VAR_0 >= 1:\n        count = count + 1\n        sm = sm + VAR_0\n        VAR_0 = VAR_0 - 2\n    return sm // count", "label": 1, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def average_Odd(z):\n    if z % 2 == 0:\n        return \"Invalid Input\"\n        return -1\n    sm = 0\n   \n    count = 0\n    while z >= 1:\n        count = count + 1\n        sm = sm + z\n        z = z - 2\n    return sm // count", "label": 1, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_add_sub_variable", "transformed_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count-1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "label": 0, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_sub_add_variable", "transformed_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return +1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "label": 0, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_div_mul_variable", "transformed_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm*/count ", "label": 0, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n<=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "label": 0, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def average_Odd(n) :\n     \n    if (n%2!=0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "label": 0, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 506, "dataset": "mbpp"},
{"original_code": "def average_Odd(n) :\n     \n    if (n%2==0) : \n        return (\"Invalid Input\") \n        return -1 \n    sm =0\n    count =0\n    while (n>=1) : \n        count=count+1\n        sm = sm + n \n        n = n-2\n    return sm//count ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 506, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_dead_code_insert", "transformed_code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0 for i in range(n + 1)] for j in range(k + 1)]\n    for i in range(1, k + 1):\n        while False:\n            dp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n       \n        for j in range(1, n + 1):\n            dp[i][j] = dp[i][j - 1]\n            if arr[j - 1] <= i and arr[j - 1] > 0:\n                dp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n    return dp[k][n]", "label": 1, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_for_while_loop", "transformed_code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0 for i in range(n + 1)] for j in range(k + 1)]\n    i = 1\n    while i < k + 1:\n       \n        for j in range(1, n + 1):\n            dp[i][j] = dp[i][j - 1]\n            if arr[j - 1] <= i and arr[j - 1] > 0:\n                dp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n        i += 1\n    return dp[k][n]", "label": 1, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_operand_swap", "transformed_code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0 for i in range(n + 1)] for j in range(k + 1)]\n    for i in range(1, k + 1):\n       \n        for j in range(1, n + 1):\n            dp[i][j] = dp[i][j - 1]\n            if i >= arr[j - 1] and arr[j - 1] > 0:\n                dp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n    return dp[k][n]", "label": 1, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_rename_variable_cb", "transformed_code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0 for i in range(n + 1)] for sk in range(k + 1)]\n    for i in range(1, k + 1):\n       \n        for sk in range(1, n + 1):\n            dp[i][sk] = dp[i][sk - 1]\n            if arr[sk - 1] <= i and arr[sk - 1] > 0:\n                dp[i][sk] += dp[i // arr[sk - 1]][sk - 1] + 1\n    return dp[k][n]", "label": 1, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_rename_variable_naive", "transformed_code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0 for i in range(n + 1)] for VAR_0 in range(k + 1)]\n    for i in range(1, k + 1):\n       \n        for VAR_0 in range(1, n + 1):\n            dp[i][VAR_0] = dp[i][VAR_0 - 1]\n            if arr[VAR_0 - 1] <= i and arr[VAR_0 - 1] > 0:\n                dp[i][VAR_0] += dp[i // arr[VAR_0 - 1]][VAR_0 - 1] + 1\n    return dp[k][n]", "label": 1, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_rename_variable_rn", "transformed_code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0 for i in range(n + 1)] for H in range(k + 1)]\n    for i in range(1, k + 1):\n       \n        for H in range(1, n + 1):\n            dp[i][H] = dp[i][H - 1]\n            if arr[H - 1] <= i and arr[H - 1] > 0:\n                dp[i][H] += dp[i // arr[H - 1]][H - 1] + 1\n    return dp[k][n]", "label": 1, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_add_sub_variable", "transformed_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n - 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_sub_add_variable", "transformed_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j + 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_div_mul_variable", "transformed_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i */ arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] >= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] < 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_and_or_variable", "transformed_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i or arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def no_of_subsequences(arr, k):\n\t \n\tn = len(arr) \n\tdp = [[0 for i in range(n + 1)] \n\t\t\tfor j in range(k + 1)] \n\tfor i in range(1, k + 1): \n\t\tfor j in range(1, n + 1): \n\t\t\tdp[i][j] = dp[i][j - 1] \n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 507, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_dead_code_insert", "transformed_code": "def radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i / placement) % RADIX)\n            for _i_1 in range(0):\n                RADIX = 10\n           \n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= RADIX\n    return nums", "label": 1, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_for_while_loop", "transformed_code": "def radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        _i_i = 0\n        while _i_i < len(nums):\n            i = nums[_i_i]\n            tmp = int((i / placement) % RADIX)\n           \n            buckets[tmp].append(i)\n            _i_i += 1\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= RADIX\n    return nums", "label": 1, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_operand_swap", "transformed_code": "def radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while max_digit > placement:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i / placement) % RADIX)\n           \n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= RADIX\n    return nums", "label": 1, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_rename_variable_cb", "transformed_code": "def radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for a2 in nums:\n            tmp = int((a2 / placement) % RADIX)\n           \n            buckets[tmp].append(a2)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for a2 in buck:\n                nums[a] = a2\n                a += 1\n        placement *= RADIX\n    return nums", "label": 1, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_rename_variable_naive", "transformed_code": "def radix_sort(nums):\n    VAR_0 = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n        buckets = [list() for _ in range(VAR_0)]\n        for i in nums:\n            tmp = int((i / placement) % VAR_0)\n           \n            buckets[tmp].append(i)\n        a = 0\n        for b in range(VAR_0):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= VAR_0\n    return nums", "label": 1, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_rename_variable_rn", "transformed_code": "def radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for Z in nums:\n            tmp = int((Z / placement) % RADIX)\n           \n            buckets[tmp].append(Z)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for Z in buck:\n                nums[a] = Z\n                a += 1\n        placement *= RADIX\n    return nums", "label": 1, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_add_sub_variable", "transformed_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a -= 1\n      placement *= RADIX\n    return nums", "label": 0, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_mul_div_variable", "transformed_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement /= RADIX\n    return nums", "label": 0, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_div_mul_variable", "transformed_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i * placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "label": 0, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement > max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "label": 0, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 513, "dataset": "mbpp"},
{"original_code": "def radix_sort(nums):\n    \n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 513, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_dead_code_insert", "transformed_code": "def largest_pos(list1):\n    for _i_5 in range(0):\n        max = list1[0]\n    max = list1[0]\n    for x in list1:\n       \n        if x > max:\n            max = x\n    return max", "label": 1, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_for_while_loop", "transformed_code": "def largest_pos(list1):\n    max = list1[0]\n    _x_i = 0\n    while _x_i < len(list1):\n        x = list1[_x_i]\n       \n        if x > max:\n            max = x\n        _x_i += 1\n    return max", "label": 1, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_operand_swap", "transformed_code": "def largest_pos(list1):\n    max = list1[0]\n    for x in list1:\n       \n        if max < x:\n            max = x\n    return max", "label": 1, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_rename_variable_cb", "transformed_code": "def largest_pos(list1):\n    pos = list1[0]\n    for x in list1:\n       \n        if x > pos:\n            pos = x\n    return pos", "label": 1, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_rename_variable_naive", "transformed_code": "def largest_pos(list1):\n    VAR_0 = list1[0]\n    for x in list1:\n       \n        if x > VAR_0:\n            VAR_0 = x\n    return VAR_0", "label": 1, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_rename_variable_rn", "transformed_code": "def largest_pos(list1):\n    Ah6 = list1[0]\n    for x in list1:\n       \n        if x > Ah6:\n            Ah6 = x\n    return Ah6", "label": 1, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "label": 0, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 514, "dataset": "mbpp"},
{"original_code": "def largest_pos(list1):\n     \n    max = list1[0] \n    for x in list1: \n        if x > max : \n             max = x  \n    return max", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 514, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_dead_code_insert", "transformed_code": "def volume_tetrahedron(num):\n    import math\n    for _i_0 in range(0):\n        return round(volume, 2)\n   \n    volume = num ** 3 / (6 * math.sqrt(2))\n    return round(volume, 2)", "label": 1, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_for_while_loop", "transformed_code": "def volume_tetrahedron(num):\n    import math\n   \n    volume = num ** 3 / (6 * math.sqrt(2))\n    return round(volume, 2)", "label": 1, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_operand_swap", "transformed_code": "def volume_tetrahedron(num):\n    import math\n   \n    volume = num ** 3 / (6 * math.sqrt(2))\n    return round(volume, 2)", "label": 1, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_rename_variable_cb", "transformed_code": "def volume_tetrahedron(num):\n    import math\n   \n    num2 = num ** 3 / (6 * math.sqrt(2))\n    return round(num2, 2)", "label": 1, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_rename_variable_naive", "transformed_code": "def volume_tetrahedron(num):\n    import math\n   \n    VAR_0 = num ** 3 / (6 * math.sqrt(2))\n    return round(VAR_0, 2)", "label": 1, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_rename_variable_rn", "transformed_code": "def volume_tetrahedron(num):\n    import math\n   \n    r34h2w = num ** 3 / (6 * math.sqrt(2))\n    return round(r34h2w, 2)", "label": 1, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_mul_div_variable", "transformed_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num /* 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "label": 0, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_div_mul_variable", "transformed_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 * (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "label": 0, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 516, "dataset": "mbpp"},
{"original_code": "def volume_tetrahedron(num):\n\timport math\n\t\n\tvolume = (num ** 3 / (6 * math.sqrt(2)))\t\n\treturn round(volume, 2)", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 516, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_dead_code_insert", "transformed_code": "def check_isosceles(x, y, z):\n    if x != y & y != z & z != x:\n        _i_8 = 0\n        if _i_8 < _i_8:\n            return True\n       \n        return True\n    else:\n        return False", "label": 1, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_for_while_loop", "transformed_code": "def check_isosceles(x, y, z):\n    if x != y & y != z & z != x:\n       \n        return True\n    else:\n        return False", "label": 1, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_operand_swap", "transformed_code": "def check_isosceles(x, y, z):\n    if x != y & y != z & z != x:\n       \n        return True\n    else:\n        return False", "label": 1, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_rename_variable_cb", "transformed_code": "def check_isosceles(x2, y, z):\n    if x2 != y & y != z & z != x2:\n       \n        return True\n    else:\n        return False", "label": 1, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_rename_variable_naive", "transformed_code": "def check_isosceles(VAR_0, y, z):\n    if VAR_0 != y & y != z & z != VAR_0:\n       \n        return True\n    else:\n        return False", "label": 1, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_rename_variable_rn", "transformed_code": "def check_isosceles(r, y, z):\n    if r != y & y != z & z != r:\n       \n        return True\n    else:\n        return False", "label": 1, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_exclamation_equalto_variable", "transformed_code": "def check_isosceles(x,y,z):\n  \n  if x==y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "label": 0, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_true_false_variable", "transformed_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return False\n  else:\n     return False", "label": 0, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_false_true_variable", "transformed_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return True", "label": 0, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 518, "dataset": "mbpp"},
{"original_code": "def check_isosceles(x,y,z):\n  \n  if x!=y & y!=z & z!=x:\n\t   return True\n  else:\n     return False", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 518, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_dead_code_insert", "transformed_code": "def lbs(arr):\n    _i_0 = 0\n    if _i_0 > _i_0:\n        for i in range(1, n):\n            for j in range(0, i):\n                if (arr[i] > arr[j]) and (lis[i] < lis[j] + 1):\n                    lis[i] = lis[j] + 1\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if (arr[i] > arr[j]) and (lis[i] < lis[j] + 1):\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n   \n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if arr[i] > arr[j] and lds[i] < lds[j] + 1:\n                lds[i] = lds[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    for i in range(1, n):\n        maximum = max((lis[i] + lds[i] - 1), maximum)\n    return maximum", "label": 1, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_for_while_loop", "transformed_code": "def lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    i = 1\n    while i < n:\n        for j in range(0, i):\n            if (arr[i] > arr[j]) and (lis[i] < lis[j] + 1):\n                lis[i] = lis[j] + 1\n        i += 1\n    lds = [1 for i in range(n + 1)]\n   \n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if arr[i] > arr[j] and lds[i] < lds[j] + 1:\n                lds[i] = lds[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    for i in range(1, n):\n        maximum = max((lis[i] + lds[i] - 1), maximum)\n    return maximum", "label": 1, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_operand_swap", "transformed_code": "def lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if (arr[i] > arr[j]) and (lis[i] < lis[j] + 1):\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n   \n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if arr[j] < arr[i] and lds[i] < lds[j] + 1:\n                lds[i] = lds[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    for i in range(1, n):\n        maximum = max((lis[i] + lds[i] - 1), maximum)\n    return maximum", "label": 1, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_rename_variable_cb", "transformed_code": "def lbs(arr):\n    n = len(arr)\n    lis = [1 for i2 in range(n + 1)]\n    for i2 in range(1, n):\n        for j in range(0, i2):\n            if (arr[i2] > arr[j]) and (lis[i2] < lis[j] + 1):\n                lis[i2] = lis[j] + 1\n    lds = [1 for i2 in range(n + 1)]\n   \n    for i2 in reversed(range(n - 1)):\n        for j in reversed(range(i2 - 1, n)):\n            if arr[i2] > arr[j] and lds[i2] < lds[j] + 1:\n                lds[i2] = lds[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    for i2 in range(1, n):\n        maximum = max((lis[i2] + lds[i2] - 1), maximum)\n    return maximum", "label": 1, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_rename_variable_naive", "transformed_code": "def lbs(arr):\n    n = len(arr)\n    lis = [1 for VAR_0 in range(n + 1)]\n    for VAR_0 in range(1, n):\n        for j in range(0, VAR_0):\n            if (arr[VAR_0] > arr[j]) and (lis[VAR_0] < lis[j] + 1):\n                lis[VAR_0] = lis[j] + 1\n    lds = [1 for VAR_0 in range(n + 1)]\n   \n    for VAR_0 in reversed(range(n - 1)):\n        for j in reversed(range(VAR_0 - 1, n)):\n            if arr[VAR_0] > arr[j] and lds[VAR_0] < lds[j] + 1:\n                lds[VAR_0] = lds[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    for VAR_0 in range(1, n):\n        maximum = max((lis[VAR_0] + lds[VAR_0] - 1), maximum)\n    return maximum", "label": 1, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_rename_variable_rn", "transformed_code": "def lbs(arr):\n    n = len(arr)\n    lis = [1 for O in range(n + 1)]\n    for O in range(1, n):\n        for j in range(0, O):\n            if (arr[O] > arr[j]) and (lis[O] < lis[j] + 1):\n                lis[O] = lis[j] + 1\n    lds = [1 for O in range(n + 1)]\n   \n    for O in reversed(range(n - 1)):\n        for j in reversed(range(O - 1, n)):\n            if arr[O] > arr[j] and lds[O] < lds[j] + 1:\n                lds[O] = lds[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    for O in range(1, n):\n        maximum = max((lis[O] + lds[O] - 1), maximum)\n    return maximum", "label": 1, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_add_sub_variable", "transformed_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n-1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "label": 0, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_sub_add_variable", "transformed_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n+1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "label": 0, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] > lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "label": 0, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] < arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "label": 0, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_and_or_variable", "transformed_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) or (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "label": 0, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 519, "dataset": "mbpp"},
{"original_code": "def lbs(arr):\n\t \n\tn = len(arr) \n\tlis = [1 for i in range(n+1)] \n\tfor i in range(1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)] \n\tfor i in reversed(range(n-1)): \n\t\tfor j in reversed(range(i-1 ,n)): \n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n): \n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \n\treturn maximum", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 519, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_dead_code_insert", "transformed_code": "def max_sum_increasing_subsequence(arr, n):\n    max = 0\n    msis = [0 for x in range(n)]\n    for i in range(n):\n        while False:\n            msis = [0 for x in range(n)]\n        msis[i] = arr[i]\n    for i in range(1, n):\n        for j in range(i):\n           \n            if arr[i] > arr[j] and msis[i] < msis[j] + arr[i]:\n                msis[i] = msis[j] + arr[i]\n    for i in range(n):\n        if max < msis[i]:\n            max = msis[i]\n    return max", "label": 1, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_for_while_loop", "transformed_code": "def max_sum_increasing_subsequence(arr, n):\n    max = 0\n    msis = [0 for x in range(n)]\n    i = 0\n    while i < n:\n        msis[i] = arr[i]\n        i += 1\n    for i in range(1, n):\n        for j in range(i):\n           \n            if arr[i] > arr[j] and msis[i] < msis[j] + arr[i]:\n                msis[i] = msis[j] + arr[i]\n    for i in range(n):\n        if max < msis[i]:\n            max = msis[i]\n    return max", "label": 1, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_operand_swap", "transformed_code": "def max_sum_increasing_subsequence(arr, n):\n    max = 0\n    msis = [0 for x in range(n)]\n    for i in range(n):\n        msis[i] = arr[i]\n    for i in range(1, n):\n        for j in range(i):\n           \n            if arr[i] > arr[j] and msis[i] < msis[j] + arr[i]:\n                msis[i] = msis[j] + arr[i]\n    for i in range(n):\n        if msis[i] > max:\n            max = msis[i]\n    return max", "label": 1, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_rename_variable_cb", "transformed_code": "def max_sum_increasing_subsequence(arr, n):\n    max = 0\n    msis = [0 for x in range(n)]\n    for i2 in range(n):\n        msis[i2] = arr[i2]\n    for i2 in range(1, n):\n        for j in range(i2):\n           \n            if arr[i2] > arr[j] and msis[i2] < msis[j] + arr[i2]:\n                msis[i2] = msis[j] + arr[i2]\n    for i2 in range(n):\n        if max < msis[i2]:\n            max = msis[i2]\n    return max", "label": 1, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_rename_variable_naive", "transformed_code": "def max_sum_increasing_subsequence(arr, n):\n    max = 0\n    msis = [0 for x in range(n)]\n    for VAR_0 in range(n):\n        msis[VAR_0] = arr[VAR_0]\n    for VAR_0 in range(1, n):\n        for j in range(VAR_0):\n           \n            if arr[VAR_0] > arr[j] and msis[VAR_0] < msis[j] + arr[VAR_0]:\n                msis[VAR_0] = msis[j] + arr[VAR_0]\n    for VAR_0 in range(n):\n        if max < msis[VAR_0]:\n            max = msis[VAR_0]\n    return max", "label": 1, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_rename_variable_rn", "transformed_code": "def max_sum_increasing_subsequence(arr, n):\n    max = 0\n    msis = [0 for x in range(n)]\n    for U in range(n):\n        msis[U] = arr[U]\n    for U in range(1, n):\n        for j in range(U):\n           \n            if arr[U] > arr[j] and msis[U] < msis[j] + arr[U]:\n                msis[U] = msis[j] + arr[U]\n    for U in range(n):\n        if max < msis[U]:\n            max = msis[U]\n    return max", "label": 1, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_add_sub_variable", "transformed_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] - arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "label": 0, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] > msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "label": 0, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] < arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "label": 0, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_and_or_variable", "transformed_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] or\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "label": 0, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 521, "dataset": "mbpp"},
{"original_code": "def max_sum_increasing_subsequence(arr, n):\n\t \n\tmax = 0\n\tmsis = [0 for x in range(n)] \n\tfor i in range(n): \n\t\tmsis[i] = arr[i] \n\tfor i in range(1, n): \n\t\tfor j in range(i): \n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \n\t\t\t\tmsis[i] = msis[j] + arr[i] \n\tfor i in range(n): \n\t\tif max < msis[i]: \n\t\t\tmax = msis[i] \n\treturn max", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 521, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_dead_code_insert", "transformed_code": "def parallel_lines(line1, line2):\n   \n    return line1[0] / line1[1] == line2[0] / line2[1]", "label": 1, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_for_while_loop", "transformed_code": "def parallel_lines(line1, line2):\n   \n    return line1[0] / line1[1] == line2[0] / line2[1]", "label": 1, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_operand_swap", "transformed_code": "def parallel_lines(line1, line2):\n   \n    return line2[0] / line2[1] == line1[0] / line1[1]", "label": 1, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_rename_variable_cb", "transformed_code": "def parallel_lines(line1, line):\n   \n    return line1[0] / line1[1] == line[0] / line[1]", "label": 1, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_rename_variable_naive", "transformed_code": "def parallel_lines(VAR_0, line2):\n   \n    return VAR_0[0] / VAR_0[1] == line2[0] / line2[1]", "label": 1, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_rename_variable_rn", "transformed_code": "def parallel_lines(line1, nc0I9):\n   \n    return line1[0] / line1[1] == nc0I9[0] / nc0I9[1]", "label": 1, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_div_mul_variable", "transformed_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]*line1[1] == line2[0]/line2[1]", "label": 0, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] != line2[0]/line2[1]", "label": 0, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 522, "dataset": "mbpp"},
{"original_code": "def parallel_lines(line1, line2):\n  \n  return line1[0]/line1[1] == line2[0]/line2[1]", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 522, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_dead_code_insert", "transformed_code": "def capitalize_first_last_letters(str1):\n    _i_5 = 0\n    while _i_5 > _i_5:\n        result = \"\"\n    str1 = result = str1.title()\n    result = \"\"\n   \n    for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n    return result[:-1]", "label": 1, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_for_while_loop", "transformed_code": "def capitalize_first_last_letters(str1):\n    str1 = result = str1.title()\n    result = \"\"\n   \n    _word_i = 0\n    while _word_i < len(str1.split()):\n        word = str1.split()[_word_i]\n        result += word[:-1] + word[-1].upper() + \" \"\n        _word_i += 1\n    return result[:-1]", "label": 1, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_operand_swap", "transformed_code": "def capitalize_first_last_letters(str1):\n    str1 = result = str1.title()\n    result = \"\"\n   \n    for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n    return result[:-1]", "label": 1, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def capitalize_first_last_letters(result2):\n    result2 = result = result2.title()\n    result = \"\"\n   \n    for word in result2.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n    return result[:-1]", "label": 1, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def capitalize_first_last_letters(VAR_0):\n    VAR_0 = result = VAR_0.title()\n    result = \"\"\n   \n    for word in VAR_0.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n    return result[:-1]", "label": 1, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def capitalize_first_last_letters(str1):\n    str1 = d7m10O = str1.title()\n    d7m10O = \"\"\n   \n    for word in str1.split():\n        d7m10O += word[:-1] + word[-1].upper() + \" \"\n    return d7m10O[:-1]", "label": 1, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_add_sub_variable", "transformed_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result -= word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "label": 0, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_sub_add_variable", "transformed_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:+1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "label": 0, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 523, "dataset": "mbpp"},
{"original_code": "def capitalize_first_last_letters(str1):\n     \n     str1 = result = str1.title()\n     result =  \"\"\n     for word in str1.split():\n        result += word[:-1] + word[-1].upper() + \" \"\n     return result[:-1]  ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 523, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_dead_code_insert", "transformed_code": "def min_length(list1):\n    _i_3 = 0\n    while _i_3 > _i_3:\n        min_length = min(len(x) for x in list1)\n    min_length = min(len(x) for x in list1)\n   \n    min_list = min((x) for x in list1)\n    return (min_length, min_list)", "label": 1, "groups": 525, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_for_while_loop", "transformed_code": "def min_length(list1):\n    min_length = min(len(x) for x in list1)\n   \n    min_list = min((x) for x in list1)\n    return (min_length, min_list)", "label": 1, "groups": 525, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_operand_swap", "transformed_code": "def min_length(list1):\n    min_length = min(len(x) for x in list1)\n   \n    min_list = min((x) for x in list1)\n    return (min_length, min_list)", "label": 1, "groups": 525, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def min_length(list1):\n    min_length = min(len(l) for l in list1)\n   \n    min_list = min((l) for l in list1)\n    return (min_length, min_list)", "label": 1, "groups": 525, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def min_length(list1):\n    min_length = min(len(VAR_0) for VAR_0 in list1)\n   \n    min_list = min((VAR_0) for VAR_0 in list1)\n    return (min_length, min_list)", "label": 1, "groups": 525, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def min_length(list1):\n    min_length = min(len(T) for T in list1)\n   \n    min_list = min((T) for T in list1)\n    return (min_length, min_list)", "label": 1, "groups": 525, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 525, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 525, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 525, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 525, "dataset": "mbpp"},
{"original_code": "def min_length(list1):\n   \n   min_length = min(len(x) for x in  list1 )  \n   min_list = min((x) for x in   list1)\n   return(min_length, min_list)     ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 525, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_dead_code_insert", "transformed_code": "def jacobsthal_lucas(n):\n    _i_6 = 0\n    if _i_6 < _i_6:\n        return dp[n]\n    dp = [0] * (n + 1)\n    dp[0] = 2\n   \n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + 2 * dp[i - 2]\n    return dp[n]", "label": 1, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_for_while_loop", "transformed_code": "def jacobsthal_lucas(n):\n    dp = [0] * (n + 1)\n    dp[0] = 2\n   \n    dp[1] = 1\n    i = 2\n    while i < n + 1:\n        dp[i] = dp[i - 1] + 2 * dp[i - 2]\n        i += 1\n    return dp[n]", "label": 1, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_operand_swap", "transformed_code": "def jacobsthal_lucas(n):\n    dp = [0] * (n + 1)\n    dp[0] = 2\n   \n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + 2 * dp[i - 2]\n    return dp[n]", "label": 1, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_rename_variable_cb", "transformed_code": "def jacobsthal_lucas(n):\n    n2 = [0] * (n + 1)\n    n2[0] = 2\n   \n    n2[1] = 1\n    for i in range(2, n + 1):\n        n2[i] = n2[i - 1] + 2 * n2[i - 2]\n    return n2[n]", "label": 1, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_rename_variable_naive", "transformed_code": "def jacobsthal_lucas(n):\n    VAR_0 = [0] * (n + 1)\n    VAR_0[0] = 2\n   \n    VAR_0[1] = 1\n    for i in range(2, n + 1):\n        VAR_0[i] = VAR_0[i - 1] + 2 * VAR_0[i - 2]\n    return VAR_0[n]", "label": 1, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_rename_variable_rn", "transformed_code": "def jacobsthal_lucas(n):\n    fO = [0] * (n + 1)\n    fO[0] = 2\n   \n    fO[1] = 1\n    for i in range(2, n + 1):\n        fO[i] = fO[i - 1] + 2 * fO[i - 2]\n    return fO[n]", "label": 1, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_add_sub_variable", "transformed_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n - 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "label": 0, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_sub_add_variable", "transformed_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i + 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "label": 0, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_mul_div_variable", "transformed_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] / (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "label": 0, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 526, "dataset": "mbpp"},
{"original_code": "def jacobsthal_lucas(n):\n\t \n\tdp=[0] * (n + 1) \n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \n\treturn dp[n]", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 526, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dead_code_insert", "transformed_code": "def negative_count(nums):\n    from array import array\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        for _i_1 in range(0):\n            n = len(nums)\n       \n        if x < 0:\n            n1 += 1\n        else:\n            None\n    return round(n1 / n, 2)", "label": 1, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_for_while_loop", "transformed_code": "def negative_count(nums):\n    from array import array\n    n = len(nums)\n    n1 = 0\n    _x_i = 0\n    while _x_i < len(nums):\n        x = nums[_x_i]\n       \n        if x < 0:\n            n1 += 1\n        else:\n            None\n        _x_i += 1\n    return round(n1 / n, 2)", "label": 1, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_operand_swap", "transformed_code": "def negative_count(nums):\n    from array import array\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n       \n        if 0 > x:\n            n1 += 1\n        else:\n            None\n    return round(n1 / n, 2)", "label": 1, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_rename_variable_cb", "transformed_code": "def negative_count(nums):\n    from array import array\n    n = len(nums)\n    n2 = 0\n    for x in nums:\n       \n        if x < 0:\n            n2 += 1\n        else:\n            None\n    return round(n2 / n, 2)", "label": 1, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_rename_variable_naive", "transformed_code": "def negative_count(nums):\n    from array import array\n    n = len(nums)\n    VAR_0 = 0\n    for x in nums:\n       \n        if x < 0:\n            VAR_0 += 1\n        else:\n            None\n    return round(VAR_0 / n, 2)", "label": 1, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_rename_variable_rn", "transformed_code": "def negative_count(Ge6R):\n    from array import array\n    n = len(Ge6R)\n    n1 = 0\n    for x in Ge6R:\n       \n        if x < 0:\n            n1 += 1\n        else:\n            None\n    return round(n1 / n, 2)", "label": 1, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_add_sub_variable", "transformed_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 -= 1\n        else:\n          None\n    return round(n1/n,2)", "label": 0, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_div_mul_variable", "transformed_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1*n,2)", "label": 0, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "label": 0, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 527, "dataset": "mbpp"},
{"original_code": "def negative_count(nums):\n    from array import array\n    \n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 527, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_dead_code_insert", "transformed_code": "def min_coins(coins, m, V):\n    import sys\n    if V == 0:\n        return 0\n    res = sys.maxsize\n    _i_5 = 0\n    while _i_5 < _i_5:\n        res = sub_res + 1\n   \n    for i in range(0, m):\n        if coins[i] <= V:\n            sub_res = min_coins(coins, m, V - coins[i])\n            if sub_res != sys.maxsize and sub_res + 1 < res:\n                res = sub_res + 1\n    return res", "label": 1, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_for_while_loop", "transformed_code": "def min_coins(coins, m, V):\n    import sys\n    if V == 0:\n        return 0\n    res = sys.maxsize\n   \n    i = 0\n    while i < m:\n        if coins[i] <= V:\n            sub_res = min_coins(coins, m, V - coins[i])\n            if sub_res != sys.maxsize and sub_res + 1 < res:\n                res = sub_res + 1\n        i += 1\n    return res", "label": 1, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_operand_swap", "transformed_code": "def min_coins(coins, m, V):\n    import sys\n    if 0 == V:\n        return 0\n    res = sys.maxsize\n   \n    for i in range(0, m):\n        if coins[i] <= V:\n            sub_res = min_coins(coins, m, V - coins[i])\n            if sub_res != sys.maxsize and sub_res + 1 < res:\n                res = sub_res + 1\n    return res", "label": 1, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def min_coins(coins, m, res2):\n    import sys\n    if res2 == 0:\n        return 0\n    res = sys.maxsize\n   \n    for i in range(0, m):\n        if coins[i] <= res2:\n            sub_res = min_coins(coins, m, res2 - coins[i])\n            if sub_res != sys.maxsize and sub_res + 1 < res:\n                res = sub_res + 1\n    return res", "label": 1, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def min_coins(VAR_0, m, V):\n    import sys\n    if V == 0:\n        return 0\n    res = sys.maxsize\n   \n    for i in range(0, m):\n        if VAR_0[i] <= V:\n            sub_res = min_coins(VAR_0, m, V - VAR_0[i])\n            if sub_res != sys.maxsize and sub_res + 1 < res:\n                res = sub_res + 1\n    return res", "label": 1, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def min_coins(coins, m, Y):\n    import sys\n    if Y == 0:\n        return 0\n    res = sys.maxsize\n   \n    for i in range(0, m):\n        if coins[i] <= Y:\n            sub_res = min_coins(coins, m, Y - coins[i])\n            if sub_res != sys.maxsize and sub_res + 1 < res:\n                res = sub_res + 1\n    return res", "label": 1, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_add_sub_variable", "transformed_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res - 1 < res): \n                res = sub_res + 1  \n    return res ", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_sub_add_variable", "transformed_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V+coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] >= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V != 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_exclamation_equalto_variable", "transformed_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res == sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_and_or_variable", "transformed_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize or sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def min_coins(coins, m, V):\n    import sys \n     \n    if (V == 0): \n        return 0\n    res = sys.maxsize \n    for i in range(0, m): \n        if (coins[i] <= V): \n            sub_res = min_coins(coins, m, V-coins[i]) \n            if (sub_res != sys.maxsize and sub_res + 1 < res): \n                res = sub_res + 1  \n    return res ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 528, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_dead_code_insert", "transformed_code": "def check_permutation(str1, str2):\n    n1 = len(str1)\n    n2 = len(str2)\n    if n1 != n2:\n        return False\n    _i_2 = 0\n    if _i_2 < _i_2:\n        if n1 != n2:\n            return False\n    a = sorted(str1)\n   \n    str1 = \" \".join(a)\n    b = sorted(str2)\n    str2 = \" \".join(b)\n    for i in range(0, n1, 1):\n        if str1[i] != str2[i]:\n            return False\n    return True", "label": 1, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_for_while_loop", "transformed_code": "def check_permutation(str1, str2):\n    n1 = len(str1)\n    n2 = len(str2)\n    if n1 != n2:\n        return False\n    a = sorted(str1)\n   \n    str1 = \" \".join(a)\n    b = sorted(str2)\n    str2 = \" \".join(b)\n    i = 0\n    while i < n1:\n        if str1[i] != str2[i]:\n            return False\n        i += 1\n    return True", "label": 1, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_operand_swap", "transformed_code": "def check_permutation(str1, str2):\n    n1 = len(str1)\n    n2 = len(str2)\n    if n2 != n1:\n        return False\n    a = sorted(str1)\n   \n    str1 = \" \".join(a)\n    b = sorted(str2)\n    str2 = \" \".join(b)\n    for i in range(0, n1, 1):\n        if str1[i] != str2[i]:\n            return False\n    return True", "label": 1, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_rename_variable_cb", "transformed_code": "def check_permutation(a2, str2):\n    n1 = len(a2)\n    n2 = len(str2)\n    if n1 != n2:\n        return False\n    a = sorted(a2)\n   \n    a2 = \" \".join(a)\n    b = sorted(str2)\n    str2 = \" \".join(b)\n    for i in range(0, n1, 1):\n        if a2[i] != str2[i]:\n            return False\n    return True", "label": 1, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_rename_variable_naive", "transformed_code": "def check_permutation(str1, VAR_0):\n    n1 = len(str1)\n    n2 = len(VAR_0)\n    if n1 != n2:\n        return False\n    a = sorted(str1)\n   \n    str1 = \" \".join(a)\n    b = sorted(VAR_0)\n    VAR_0 = \" \".join(b)\n    for i in range(0, n1, 1):\n        if str1[i] != VAR_0[i]:\n            return False\n    return True", "label": 1, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_rename_variable_rn", "transformed_code": "def check_permutation(str1, dv33):\n    n1 = len(str1)\n    n2 = len(dv33)\n    if n1 != n2:\n        return False\n    a = sorted(str1)\n   \n    str1 = \" \".join(a)\n    b = sorted(dv33)\n    dv33 = \" \".join(b)\n    for i in range(0, n1, 1):\n        if str1[i] != dv33[i]:\n            return False\n    return True", "label": 1, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_exclamation_equalto_variable", "transformed_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1==n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "label": 0, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_true_false_variable", "transformed_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return False", "label": 0, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_false_true_variable", "transformed_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return True\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "label": 0, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 529, "dataset": "mbpp"},
{"original_code": "def check_permutation(str1, str2):\n  \n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 529, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def remove_datatype(test_tuple, data_type):\n    res = []\n    for ele in test_tuple:\n        _i_3 = 0\n        while _i_3 > _i_3:\n            if not isinstance(ele, data_type):\n                res.append(ele)\n       \n        if not isinstance(ele, data_type):\n            res.append(ele)\n    return res", "label": 1, "groups": 530, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_for_while_loop", "transformed_code": "def remove_datatype(test_tuple, data_type):\n    res = []\n    _ele_i = 0\n    while _ele_i < len(test_tuple):\n        ele = test_tuple[_ele_i]\n       \n        if not isinstance(ele, data_type):\n            res.append(ele)\n        _ele_i += 1\n    return res", "label": 1, "groups": 530, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_operand_swap", "transformed_code": "def remove_datatype(test_tuple, data_type):\n    res = []\n    for ele in test_tuple:\n       \n        if not isinstance(ele, data_type):\n            res.append(ele)\n    return res", "label": 1, "groups": 530, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def remove_datatype(test_tuple, data_type):\n    result = []\n    for ele in test_tuple:\n       \n        if not isinstance(ele, data_type):\n            result.append(ele)\n    return result", "label": 1, "groups": 530, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def remove_datatype(test_tuple, data_type):\n    VAR_0 = []\n    for ele in test_tuple:\n       \n        if not isinstance(ele, data_type):\n            VAR_0.append(ele)\n    return VAR_0", "label": 1, "groups": 530, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def remove_datatype(test_tuple, data_type):\n    s71 = []\n    for ele in test_tuple:\n       \n        if not isinstance(ele, data_type):\n            s71.append(ele)\n    return s71", "label": 1, "groups": 530, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 530, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 530, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 530, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 530, "dataset": "mbpp"},
{"original_code": "def remove_datatype(test_tuple, data_type):\n  \n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 530, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_dead_code_insert", "transformed_code": "def search_literal(pattern, text):\n    while False:\n        return (s, e)\n    import re\n    match = re.search(pattern, text)\n   \n    s = match.start()\n    e = match.end()\n    return (s, e)", "label": 1, "groups": 531, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_for_while_loop", "transformed_code": "def search_literal(pattern, text):\n    import re\n    match = re.search(pattern, text)\n   \n    s = match.start()\n    e = match.end()\n    return (s, e)", "label": 1, "groups": 531, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_operand_swap", "transformed_code": "def search_literal(pattern, text):\n    import re\n    match = re.search(pattern, text)\n   \n    s = match.start()\n    e = match.end()\n    return (s, e)", "label": 1, "groups": 531, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_rename_variable_cb", "transformed_code": "def search_literal(pattern, text):\n    import re\n    r = re.search(pattern, text)\n   \n    s = r.start()\n    e = r.end()\n    return (s, e)", "label": 1, "groups": 531, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_rename_variable_naive", "transformed_code": "def search_literal(pattern, text):\n    import re\n    VAR_0 = re.search(pattern, text)\n   \n    s = VAR_0.start()\n    e = VAR_0.end()\n    return (s, e)", "label": 1, "groups": 531, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_rename_variable_rn", "transformed_code": "def search_literal(pattern, text):\n    import re\n    l31T1 = re.search(pattern, text)\n   \n    s = l31T1.start()\n    e = l31T1.end()\n    return (s, e)", "label": 1, "groups": 531, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 531, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 531, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 531, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 531, "dataset": "mbpp"},
{"original_code": "def search_literal(pattern,text):\n import re\n \n match = re.search(pattern, text)\n s = match.start()\n e = match.end()\n return (s, e)", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 531, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_dead_code_insert", "transformed_code": "def topbottom_surfacearea(r):\n    _i_4 = 0\n    while _i_4 < _i_4:\n        toporbottomarea = 3.1415 * r * r\n   \n    toporbottomarea = 3.1415 * r * r\n    return toporbottomarea", "label": 1, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_for_while_loop", "transformed_code": "def topbottom_surfacearea(r):\n   \n    toporbottomarea = 3.1415 * r * r\n    return toporbottomarea", "label": 1, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_operand_swap", "transformed_code": "def topbottom_surfacearea(r):\n   \n    toporbottomarea = 3.1415 * r * r\n    return toporbottomarea", "label": 1, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_rename_variable_cb", "transformed_code": "def topbottom_surfacearea(p):\n   \n    toporbottomarea = 3.1415 * p * p\n    return toporbottomarea", "label": 1, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_rename_variable_naive", "transformed_code": "def topbottom_surfacearea(VAR_0):\n   \n    toporbottomarea = 3.1415 * VAR_0 * VAR_0\n    return toporbottomarea", "label": 1, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_rename_variable_rn", "transformed_code": "def topbottom_surfacearea(p):\n   \n    toporbottomarea = 3.1415 * p * p\n    return toporbottomarea", "label": 1, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_mul_div_variable", "transformed_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415/r*r\n  return toporbottomarea", "label": 0, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 532, "dataset": "mbpp"},
{"original_code": "def topbottom_surfacearea(r):\n  \n  toporbottomarea=3.1415*r*r\n  return toporbottomarea", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 532, "dataset": "mbpp"},
{"original_code": "def nth_items(list,n):\n \n return list[::n]", "transformation": "transformation_dead_code_insert", "transformed_code": "def nth_items(list, n):\n    for _i_9 in range(0):\n        return list[::n]\n   \n    return list[::n]", "label": 1, "groups": 533, "dataset": "mbpp"},
{"original_code": "def nth_items(list,n):\n \n return list[::n]", "transformation": "transformation_for_while_loop", "transformed_code": "def nth_items(list, n):\n   \n    return list[::n]", "label": 1, "groups": 533, "dataset": "mbpp"},
{"original_code": "def nth_items(list,n):\n \n return list[::n]", "transformation": "transformation_operand_swap", "transformed_code": "def nth_items(list, n):\n   \n    return list[::n]", "label": 1, "groups": 533, "dataset": "mbpp"},
{"original_code": "def nth_items(list,n):\n \n return list[::n]", "transformation": "transformation_rename_variable_naive", "transformed_code": "def nth_items(list, VAR_0):\n   \n    return list[::VAR_0]", "label": 1, "groups": 533, "dataset": "mbpp"},
{"original_code": "def nth_items(list,n):\n \n return list[::n]", "transformation": "transformation_rename_variable_rn", "transformed_code": "def nth_items(list, G):\n   \n    return list[::G]", "label": 1, "groups": 533, "dataset": "mbpp"},
{"original_code": "def nth_items(list,n):\n \n return list[::n]", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 533, "dataset": "mbpp"},
{"original_code": "def nth_items(list,n):\n \n return list[::n]", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 533, "dataset": "mbpp"},
{"original_code": "def nth_items(list,n):\n \n return list[::n]", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 533, "dataset": "mbpp"},
{"original_code": "def nth_items(list,n):\n \n return list[::n]", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 533, "dataset": "mbpp"},
{"original_code": "def nth_items(list,n):\n \n return list[::n]", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 533, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_dead_code_insert", "transformed_code": "def string_list_to_tuple(str1):\n    for _i_9 in range(0):\n        return result\n   \n    result = tuple(x for x in str1 if not x.isspace())\n    return result", "label": 1, "groups": 535, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_for_while_loop", "transformed_code": "def string_list_to_tuple(str1):\n   \n    result = tuple(x for x in str1 if not x.isspace())\n    return result", "label": 1, "groups": 535, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_operand_swap", "transformed_code": "def string_list_to_tuple(str1):\n   \n    result = tuple(x for x in str1 if not x.isspace())\n    return result", "label": 1, "groups": 535, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_rename_variable_cb", "transformed_code": "def string_list_to_tuple(str1):\n   \n    result = tuple(s for s in str1 if not s.isspace())\n    return result", "label": 1, "groups": 535, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_rename_variable_naive", "transformed_code": "def string_list_to_tuple(str1):\n   \n    result = tuple(VAR_0 for VAR_0 in str1 if not VAR_0.isspace())\n    return result", "label": 1, "groups": 535, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_rename_variable_rn", "transformed_code": "def string_list_to_tuple(str1):\n   \n    result = tuple(C for C in str1 if not C.isspace())\n    return result", "label": 1, "groups": 535, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 535, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 535, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 535, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 535, "dataset": "mbpp"},
{"original_code": "def string_list_to_tuple(str1):\n    \n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 535, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_dead_code_insert", "transformed_code": "def check_abundant(n):\n    import math\n    def get_sum(n):\n        sum = 0\n        i = 1\n        while i <= (math.sqrt(n)):\n            if n % i == 0:\n                for _i_5 in range(0):\n                    import math\n                if n / i == i:\n                    sum = sum + i\n                else:\n                   \n                    sum = sum + i\n                    sum = sum + (n / i)\n            i = i + 1\n        sum = sum - n\n        return sum\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "label": 1, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_for_while_loop", "transformed_code": "def check_abundant(n):\n    import math\n    def get_sum(n):\n        sum = 0\n        i = 1\n        while i <= (math.sqrt(n)):\n            if n % i == 0:\n                if n / i == i:\n                    sum = sum + i\n                else:\n                   \n                    sum = sum + i\n                    sum = sum + (n / i)\n            i = i + 1\n        sum = sum - n\n        return sum\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "label": 1, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_operand_swap", "transformed_code": "def check_abundant(n):\n    import math\n    def get_sum(n):\n        sum = 0\n        i = 1\n        while i <= (math.sqrt(n)):\n            if n % i == 0:\n                if n / i == i:\n                    sum = sum + i\n                else:\n                   \n                    sum = sum + i\n                    sum = sum + (n / i)\n            i = i + 1\n        sum = sum - n\n        return sum\n    if n < get_sum(n):\n        return True\n    else:\n        return False", "label": 1, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_rename_variable_cb", "transformed_code": "def check_abundant(n):\n    import math\n    def get_sum(n):\n        sum = 0\n        n2 = 1\n        while n2 <= (math.sqrt(n)):\n            if n % n2 == 0:\n                if n / n2 == n2:\n                    sum = sum + n2\n                else:\n                   \n                    sum = sum + n2\n                    sum = sum + (n / n2)\n            n2 = n2 + 1\n        sum = sum - n\n        return sum\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "label": 1, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_rename_variable_naive", "transformed_code": "def check_abundant(n):\n    import math\n    def get_sum(n):\n        VAR_0 = 0\n        i = 1\n        while i <= (math.sqrt(n)):\n            if n % i == 0:\n                if n / i == i:\n                    VAR_0 = VAR_0 + i\n                else:\n                   \n                    VAR_0 = VAR_0 + i\n                    VAR_0 = VAR_0 + (n / i)\n            i = i + 1\n        VAR_0 = VAR_0 - n\n        return VAR_0\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "label": 1, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_rename_variable_rn", "transformed_code": "def check_abundant(n):\n    import math\n    def get_sum(n):\n        sum = 0\n        X = 1\n        while X <= (math.sqrt(n)):\n            if n % X == 0:\n                if n / X == X:\n                    sum = sum + X\n                else:\n                   \n                    sum = sum + X\n                    sum = sum + (n / X)\n            X = X + 1\n        sum = sum - n\n        return sum\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "label": 1, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_add_sub_variable", "transformed_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum - i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_sub_add_variable", "transformed_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum + n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_div_mul_variable", "transformed_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n*i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i >= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) < n): \n\t\treturn True\n\telse: \n\t\treturn False", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i != 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_true_false_variable", "transformed_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn False\n\telse: \n\t\treturn False", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_false_true_variable", "transformed_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn True", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def check_abundant(n):\n\timport math \n\tdef get_sum(n): \n\t\tsum = 0\n\t\ti = 1\n\t\twhile i <= (math.sqrt(n)): \n\t\t\tif n%i == 0: \n\t\t\t\tif n/i == i : \n\t\t\t\t\tsum = sum + i \n\t\t\t\telse: \n\t\t\t\t\tsum = sum + i \n\t\t\t\t\tsum = sum + (n / i ) \n\t\t\ti = i + 1\n\t\tsum = sum - n \n\t\treturn sum\n\t \n\tif (get_sum(n) > n): \n\t\treturn True\n\telse: \n\t\treturn False", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 538, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_dead_code_insert", "transformed_code": "def fill_spaces(text):\n    import re\n    if False:\n        import re\n   \n    return re.sub(\"[ ,.]\", \":\", text)", "label": 1, "groups": 539, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_for_while_loop", "transformed_code": "def fill_spaces(text):\n    import re\n   \n    return re.sub(\"[ ,.]\", \":\", text)", "label": 1, "groups": 539, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_operand_swap", "transformed_code": "def fill_spaces(text):\n    import re\n   \n    return re.sub(\"[ ,.]\", \":\", text)", "label": 1, "groups": 539, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_rename_variable_cb", "transformed_code": "def fill_spaces(line):\n    import re\n   \n    return re.sub(\"[ ,.]\", \":\", line)", "label": 1, "groups": 539, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_rename_variable_naive", "transformed_code": "def fill_spaces(VAR_0):\n    import re\n   \n    return re.sub(\"[ ,.]\", \":\", VAR_0)", "label": 1, "groups": 539, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_rename_variable_rn", "transformed_code": "def fill_spaces(i0tH):\n    import re\n   \n    return re.sub(\"[ ,.]\", \":\", i0tH)", "label": 1, "groups": 539, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 539, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 539, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 539, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 539, "dataset": "mbpp"},
{"original_code": "def fill_spaces(text):\n  import re\n  \n  return (re.sub(\"[ ,.]\", \":\", text))", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 539, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def toggle_F_and_L_bits(n):\n    def take_L_and_F_set_bits(n):\n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        _i_5 = 0\n        while _i_5 < _i_5:\n            n = n | n >> 4\n        n = n | n >> 8\n       \n        n = n | n >> 16\n        return ((n + 1) >> 1) + 1\n    if n == 1:\n        return 0\n    return n ^ take_L_and_F_set_bits(n)", "label": 1, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_for_while_loop", "transformed_code": "def toggle_F_and_L_bits(n):\n    def take_L_and_F_set_bits(n):\n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n       \n        n = n | n >> 16\n        return ((n + 1) >> 1) + 1\n    if n == 1:\n        return 0\n    return n ^ take_L_and_F_set_bits(n)", "label": 1, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_operand_swap", "transformed_code": "def toggle_F_and_L_bits(n):\n    def take_L_and_F_set_bits(n):\n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n       \n        n = n | n >> 16\n        return ((n + 1) >> 1) + 1\n    if 1 == n:\n        return 0\n    return n ^ take_L_and_F_set_bits(n)", "label": 1, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def toggle_F_and_L_bits(pri):\n    def take_L_and_F_set_bits(pri):\n        pri = pri | pri >> 1\n        pri = pri | pri >> 2\n        pri = pri | pri >> 4\n        pri = pri | pri >> 8\n       \n        pri = pri | pri >> 16\n        return ((pri + 1) >> 1) + 1\n    if pri == 1:\n        return 0\n    return pri ^ take_L_and_F_set_bits(pri)", "label": 1, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def toggle_F_and_L_bits(VAR_0):\n    def take_L_and_F_set_bits(VAR_0):\n        VAR_0 = VAR_0 | VAR_0 >> 1\n        VAR_0 = VAR_0 | VAR_0 >> 2\n        VAR_0 = VAR_0 | VAR_0 >> 4\n        VAR_0 = VAR_0 | VAR_0 >> 8\n       \n        VAR_0 = VAR_0 | VAR_0 >> 16\n        return ((VAR_0 + 1) >> 1) + 1\n    if VAR_0 == 1:\n        return 0\n    return VAR_0 ^ take_L_and_F_set_bits(VAR_0)", "label": 1, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def toggle_F_and_L_bits(y):\n    def take_L_and_F_set_bits(y):\n        y = y | y >> 1\n        y = y | y >> 2\n        y = y | y >> 4\n        y = y | y >> 8\n       \n        y = y | y >> 16\n        return ((y + 1) >> 1) + 1\n    if y == 1:\n        return 0\n    return y ^ take_L_and_F_set_bits(y)", "label": 1, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_add_sub_variable", "transformed_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n - 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "label": 0, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n <> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "label": 0, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n != 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "label": 0, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 542, "dataset": "mbpp"},
{"original_code": "def toggle_F_and_L_bits(n) :\n    def take_L_and_F_set_bits(n) : \n        n = n | n >> 1\n        n = n | n >> 2\n        n = n | n >> 4\n        n = n | n >> 8\n        n = n | n >> 16 \n        return ((n + 1) >> 1) + 1      \n      \n    if (n == 1) : \n        return 0 \n    return n ^ take_L_and_F_set_bits(n) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 542, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_dead_code_insert", "transformed_code": "def last_occurence_char(string, char):\n    flag = -1\n    for i in range(len(string)):\n        _i_2 = 0\n        while _i_2 < _i_2:\n            return None\n        if string[i] == char:\n           \n            flag = i\n    if flag == -1:\n        return None\n    else:\n        return flag + 1", "label": 1, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_for_while_loop", "transformed_code": "def last_occurence_char(string, char):\n    flag = -1\n    i = 0\n    while i < len(string):\n        if string[i] == char:\n           \n            flag = i\n        i += 1\n    if flag == -1:\n        return None\n    else:\n        return flag + 1", "label": 1, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_operand_swap", "transformed_code": "def last_occurence_char(string, char):\n    flag = -1\n    for i in range(len(string)):\n        if string[i] == char:\n           \n            flag = i\n    if -1 == flag:\n        return None\n    else:\n        return flag + 1", "label": 1, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_rename_variable_cb", "transformed_code": "def last_occurence_char(string, char):\n    i2 = -1\n    for i in range(len(string)):\n        if string[i] == char:\n           \n            i2 = i\n    if i2 == -1:\n        return None\n    else:\n        return i2 + 1", "label": 1, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_rename_variable_naive", "transformed_code": "def last_occurence_char(string, char):\n    VAR_0 = -1\n    for i in range(len(string)):\n        if string[i] == char:\n           \n            VAR_0 = i\n    if VAR_0 == -1:\n        return None\n    else:\n        return VAR_0 + 1", "label": 1, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_rename_variable_rn", "transformed_code": "def last_occurence_char(string, char):\n    VfQ8 = -1\n    for i in range(len(string)):\n        if string[i] == char:\n           \n            VfQ8 = i\n    if VfQ8 == -1:\n        return None\n    else:\n        return VfQ8 + 1", "label": 1, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_add_sub_variable", "transformed_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag - 1", "label": 0, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_sub_add_variable", "transformed_code": "def last_occurence_char(string,char):\n \n flag = +1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "label": 0, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] != char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "label": 0, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 543, "dataset": "mbpp"},
{"original_code": "def last_occurence_char(string,char):\n \n flag = -1\n for i in range(len(string)):\n     if(string[i] == char):\n         flag = i\n if(flag == -1):\n    return None\n else:\n    return flag + 1", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 543, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_dead_code_insert", "transformed_code": "def Total_Hamming_Distance(n):\n    i = 1\n    for _i_2 in range(0):\n        i = 1\n    sum = 0\n   \n    while n // i > 0:\n        sum = sum + n // i\n        i = i * 2\n    return sum", "label": 1, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_for_while_loop", "transformed_code": "def Total_Hamming_Distance(n):\n    i = 1\n    sum = 0\n   \n    while n // i > 0:\n        sum = sum + n // i\n        i = i * 2\n    return sum", "label": 1, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_operand_swap", "transformed_code": "def Total_Hamming_Distance(n):\n    i = 1\n    sum = 0\n   \n    while 0 < n // i:\n        sum = sum + n // i\n        i = i * 2\n    return sum", "label": 1, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_rename_variable_cb", "transformed_code": "def Total_Hamming_Distance(n):\n    n2 = 1\n    sum = 0\n   \n    while n // n2 > 0:\n        sum = sum + n // n2\n        n2 = n2 * 2\n    return sum", "label": 1, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_rename_variable_naive", "transformed_code": "def Total_Hamming_Distance(n):\n    VAR_0 = 1\n    sum = 0\n   \n    while n // VAR_0 > 0:\n        sum = sum + n // VAR_0\n        VAR_0 = VAR_0 * 2\n    return sum", "label": 1, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_rename_variable_rn", "transformed_code": "def Total_Hamming_Distance(n):\n    k = 1\n    sum = 0\n   \n    while n // k > 0:\n        sum = sum + n // k\n        k = k * 2\n    return sum", "label": 1, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_add_sub_variable", "transformed_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum - n // i  \n        i = i * 2     \n    return sum", "label": 0, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_mul_div_variable", "transformed_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i / 2     \n    return sum", "label": 0, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_div_mul_variable", "transformed_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n */ i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "label": 0, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i < 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "label": 0, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 544, "dataset": "mbpp"},
{"original_code": "def Total_Hamming_Distance(n):\n       \n    i = 1\n    sum = 0\n    while (n // i > 0):  \n        sum = sum + n // i  \n        i = i * 2     \n    return sum", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 544, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_dead_code_insert", "transformed_code": "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    longest_increasing_subsequence = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            for _i_1 in range(0):\n                maximum = max(maximum, longest_increasing_subsequence[i])\n           \n            if (\n                arr[i] > arr[j]\n                and longest_increasing_subsequence[i]\n                < longest_increasing_subsequence[j] + 1\n            ):\n                longest_increasing_subsequence[i] = (\n                    longest_increasing_subsequence[j] + 1\n                )\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, longest_increasing_subsequence[i])\n    return maximum", "label": 1, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_for_while_loop", "transformed_code": "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    longest_increasing_subsequence = [1] * n\n    i = 1\n    while i < n:\n        for j in range(0, i):\n           \n            if (\n                arr[i] > arr[j]\n                and longest_increasing_subsequence[i]\n                < longest_increasing_subsequence[j] + 1\n            ):\n                longest_increasing_subsequence[i] = (\n                    longest_increasing_subsequence[j] + 1\n                )\n        i += 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, longest_increasing_subsequence[i])\n    return maximum", "label": 1, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_operand_swap", "transformed_code": "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    longest_increasing_subsequence = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n           \n            if (\n                arr[j] < arr[i]\n                and longest_increasing_subsequence[i]\n                < longest_increasing_subsequence[j] + 1\n            ):\n                longest_increasing_subsequence[i] = (\n                    longest_increasing_subsequence[j] + 1\n                )\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, longest_increasing_subsequence[i])\n    return maximum", "label": 1, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_rename_variable_cb", "transformed_code": "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    longest_increasing_subsequence = [1] * n\n    for i2 in range(1, n):\n        for j in range(0, i2):\n           \n            if (\n                arr[i2] > arr[j]\n                and longest_increasing_subsequence[i2]\n                < longest_increasing_subsequence[j] + 1\n            ):\n                longest_increasing_subsequence[i2] = (\n                    longest_increasing_subsequence[j] + 1\n                )\n    maximum = 0\n    for i2 in range(n):\n        maximum = max(maximum, longest_increasing_subsequence[i2])\n    return maximum", "label": 1, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_rename_variable_naive", "transformed_code": "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    longest_increasing_subsequence = [1] * n\n    for VAR_0 in range(1, n):\n        for j in range(0, VAR_0):\n           \n            if (\n                arr[VAR_0] > arr[j]\n                and longest_increasing_subsequence[VAR_0]\n                < longest_increasing_subsequence[j] + 1\n            ):\n                longest_increasing_subsequence[VAR_0] = (\n                    longest_increasing_subsequence[j] + 1\n                )\n    maximum = 0\n    for VAR_0 in range(n):\n        maximum = max(maximum, longest_increasing_subsequence[VAR_0])\n    return maximum", "label": 1, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_rename_variable_rn", "transformed_code": "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    longest_increasing_subsequence = [1] * n\n    for N in range(1, n):\n        for j in range(0, N):\n           \n            if (\n                arr[N] > arr[j]\n                and longest_increasing_subsequence[N]\n                < longest_increasing_subsequence[j] + 1\n            ):\n                longest_increasing_subsequence[N] = (\n                    longest_increasing_subsequence[j] + 1\n                )\n    maximum = 0\n    for N in range(n):\n        maximum = max(maximum, longest_increasing_subsequence[N])\n    return maximum", "label": 1, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_add_sub_variable", "transformed_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] - 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "label": 0, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_mul_div_variable", "transformed_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]/n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "label": 0, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]> longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "label": 0, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] < arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "label": 0, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_and_or_variable", "transformed_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] or longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "label": 0, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 545, "dataset": "mbpp"},
{"original_code": "def longest_increasing_subsequence(arr):\n\t \n\tn = len(arr) \n\tlongest_increasing_subsequence = [1]*n \n\tfor i in range (1 , n): \n\t\tfor j in range(0 , i): \n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 : \n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n): \n\t\tmaximum = max(maximum , longest_increasing_subsequence[i]) \n\treturn maximum", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 545, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def find_Max(arr, low, high):\n    if False:\n        return arr[0]\n    if high < low:\n        return arr[0]\n    if high == low:\n        return arr[low]\n    mid = low + (high - low) // 2\n    if mid < high and arr[mid + 1] < arr[mid]:\n       \n        return arr[mid]\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid - 1]\n    if arr[low] > arr[mid]:\n        return find_Max(arr, low, mid - 1)\n    else:\n        return find_Max(arr, mid + 1, high)", "label": 1, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_for_while_loop", "transformed_code": "def find_Max(arr, low, high):\n    if high < low:\n        return arr[0]\n    if high == low:\n        return arr[low]\n    mid = low + (high - low) // 2\n    if mid < high and arr[mid + 1] < arr[mid]:\n       \n        return arr[mid]\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid - 1]\n    if arr[low] > arr[mid]:\n        return find_Max(arr, low, mid - 1)\n    else:\n        return find_Max(arr, mid + 1, high)", "label": 1, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_operand_swap", "transformed_code": "def find_Max(arr, low, high):\n    if low > high:\n        return arr[0]\n    if high == low:\n        return arr[low]\n    mid = low + (high - low) // 2\n    if mid < high and arr[mid + 1] < arr[mid]:\n       \n        return arr[mid]\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid - 1]\n    if arr[low] > arr[mid]:\n        return find_Max(arr, low, mid - 1)\n    else:\n        return find_Max(arr, mid + 1, high)", "label": 1, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def find_Max(max, low, high):\n    if high < low:\n        return max[0]\n    if high == low:\n        return max[low]\n    mid = low + (high - low) // 2\n    if mid < high and max[mid + 1] < max[mid]:\n       \n        return max[mid]\n    if mid > low and max[mid] < max[mid - 1]:\n        return max[mid - 1]\n    if max[low] > max[mid]:\n        return find_Max(max, low, mid - 1)\n    else:\n        return find_Max(max, mid + 1, high)", "label": 1, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def find_Max(VAR_0, low, high):\n    if high < low:\n        return VAR_0[0]\n    if high == low:\n        return VAR_0[low]\n    mid = low + (high - low) // 2\n    if mid < high and VAR_0[mid + 1] < VAR_0[mid]:\n       \n        return VAR_0[mid]\n    if mid > low and VAR_0[mid] < VAR_0[mid - 1]:\n        return VAR_0[mid - 1]\n    if VAR_0[low] > VAR_0[mid]:\n        return find_Max(VAR_0, low, mid - 1)\n    else:\n        return find_Max(VAR_0, mid + 1, high)", "label": 1, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def find_Max(w8a, low, high):\n    if high < low:\n        return w8a[0]\n    if high == low:\n        return w8a[low]\n    mid = low + (high - low) // 2\n    if mid < high and w8a[mid + 1] < w8a[mid]:\n       \n        return w8a[mid]\n    if mid > low and w8a[mid] < w8a[mid - 1]:\n        return w8a[mid - 1]\n    if w8a[low] > w8a[mid]:\n        return find_Max(w8a, low, mid - 1)\n    else:\n        return find_Max(w8a, mid + 1, high)", "label": 1, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_add_sub_variable", "transformed_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low - (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_sub_add_variable", "transformed_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high + low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_div_mul_variable", "transformed_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) */ 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def find_Max(arr,low,high):\n     \n    if (high > low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid < low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high != low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_and_or_variable", "transformed_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high or arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def find_Max(arr,low,high):\n     \n    if (high < low): \n        return arr[0] \n    if (high == low): \n        return arr[low] \n    mid = low + (high - low) // 2 \n    if (mid < high and arr[mid + 1] < arr[mid]): \n        return arr[mid] \n    if (mid > low and arr[mid] < arr[mid - 1]): \n        return arr[mid - 1]  \n    if (arr[low] > arr[mid]): \n        return find_Max(arr,low,mid - 1) \n    else: \n        return find_Max(arr,mid + 1,high) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 547, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_dead_code_insert", "transformed_code": "def extract_column(list1, n):\n    _i_5 = 0\n    if _i_5 > _i_5:\n        result = [i.pop(n) for i in list1]\n   \n    result = [i.pop(n) for i in list1]\n    return result", "label": 1, "groups": 548, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_for_while_loop", "transformed_code": "def extract_column(list1, n):\n   \n    result = [i.pop(n) for i in list1]\n    return result", "label": 1, "groups": 548, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_operand_swap", "transformed_code": "def extract_column(list1, n):\n   \n    result = [i.pop(n) for i in list1]\n    return result", "label": 1, "groups": 548, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def extract_column(list1, n):\n   \n    result = [pr.pop(n) for pr in list1]\n    return result", "label": 1, "groups": 548, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def extract_column(list1, VAR_0):\n   \n    result = [i.pop(VAR_0) for i in list1]\n    return result", "label": 1, "groups": 548, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def extract_column(list1, n):\n   \n    result = [l.pop(n) for l in list1]\n    return result", "label": 1, "groups": 548, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 548, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 548, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 548, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 548, "dataset": "mbpp"},
{"original_code": "def extract_column(list1, n):\n   \n   result = [i.pop(n) for i in list1]\n   return result ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 548, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_dead_code_insert", "transformed_code": "def Seq_Linear(seq_nums):\n    seq_nums = [seq_nums[x] - seq_nums[x - 1] for x in range(1, len(seq_nums))]\n    if len(set(seq_nums)) == 1:\n        _i_9 = 0\n        while _i_9 < _i_9:\n            return \"Non Linear Sequence\"\n       \n        return \"Linear Sequence\"\n    else:\n        return \"Non Linear Sequence\"", "label": 1, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_for_while_loop", "transformed_code": "def Seq_Linear(seq_nums):\n    seq_nums = [seq_nums[x] - seq_nums[x - 1] for x in range(1, len(seq_nums))]\n    if len(set(seq_nums)) == 1:\n       \n        return \"Linear Sequence\"\n    else:\n        return \"Non Linear Sequence\"", "label": 1, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_operand_swap", "transformed_code": "def Seq_Linear(seq_nums):\n    seq_nums = [seq_nums[x] - seq_nums[x - 1] for x in range(1, len(seq_nums))]\n    if 1 == len(set(seq_nums)):\n       \n        return \"Linear Sequence\"\n    else:\n        return \"Non Linear Sequence\"", "label": 1, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_rename_variable_cb", "transformed_code": "def Seq_Linear(seq):\n    seq = [seq[x] - seq[x - 1] for x in range(1, len(seq))]\n    if len(set(seq)) == 1:\n       \n        return \"Linear Sequence\"\n    else:\n        return \"Non Linear Sequence\"", "label": 1, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_rename_variable_naive", "transformed_code": "def Seq_Linear(VAR_0):\n    VAR_0 = [VAR_0[x] - VAR_0[x - 1] for x in range(1, len(VAR_0))]\n    if len(set(VAR_0)) == 1:\n       \n        return \"Linear Sequence\"\n    else:\n        return \"Non Linear Sequence\"", "label": 1, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_rename_variable_rn", "transformed_code": "def Seq_Linear(N29dq7S8):\n    N29dq7S8 = [N29dq7S8[x] - N29dq7S8[x - 1] for x in range(1, len(N29dq7S8))]\n    if len(set(N29dq7S8)) == 1:\n       \n        return \"Linear Sequence\"\n    else:\n        return \"Non Linear Sequence\"", "label": 1, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_sub_add_variable", "transformed_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] + seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "label": 0, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) != 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "label": 0, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Seq_Linear(seq_nums):\n  \n  seq_nums = [seq_nums[x] - seq_nums[x-1] for x in range(1, len(seq_nums))]\n  if len(set(seq_nums)) == 1: \n    return \"Linear Sequence\"\n  else:\n    return \"Non Linear Sequence\"", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 549, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_dead_code_insert", "transformed_code": "def Split(list):\n    od_li = []\n    for i in list:\n        for _i_2 in range(0):\n            od_li.append(i)\n       \n        if i % 2 != 0:\n            od_li.append(i)\n    return od_li", "label": 1, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_for_while_loop", "transformed_code": "def Split(list):\n    od_li = []\n    _i_i = 0\n    while _i_i < len(list):\n        i = list[_i_i]\n       \n        if i % 2 != 0:\n            od_li.append(i)\n        _i_i += 1\n    return od_li", "label": 1, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_operand_swap", "transformed_code": "def Split(list):\n    od_li = []\n    for i in list:\n       \n        if 0 != i % 2:\n            od_li.append(i)\n    return od_li", "label": 1, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_rename_variable_cb", "transformed_code": "def Split(list):\n    od_li = []\n    for st in list:\n       \n        if st % 2 != 0:\n            od_li.append(st)\n    return od_li", "label": 1, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_rename_variable_naive", "transformed_code": "def Split(list):\n    VAR_0 = []\n    for i in list:\n       \n        if i % 2 != 0:\n            VAR_0.append(i)\n    return VAR_0", "label": 1, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_rename_variable_rn", "transformed_code": "def Split(list):\n    zWO28 = []\n    for i in list:\n       \n        if i % 2 != 0:\n            zWO28.append(i)\n    return zWO28", "label": 1, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_exclamation_equalto_variable", "transformed_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 == 0): \n            od_li.append(i)  \n    return od_li", "label": 0, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 551, "dataset": "mbpp"},
{"original_code": "def Split(list):\n     \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 551, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_dead_code_insert", "transformed_code": "def difference(n):\n    S = (n * (n + 1)) // 2\n    if False:\n        S = (n * (n + 1)) // 2\n   \n    res = S * (S - 1)\n    return res", "label": 1, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_for_while_loop", "transformed_code": "def difference(n):\n    S = (n * (n + 1)) // 2\n   \n    res = S * (S - 1)\n    return res", "label": 1, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_operand_swap", "transformed_code": "def difference(n):\n    S = (n * (n + 1)) // 2\n   \n    res = S * (S - 1)\n    return res", "label": 1, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def difference(n):\n    n2 = (n * (n + 1)) // 2\n   \n    res = n2 * (n2 - 1)\n    return res", "label": 1, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def difference(n):\n    VAR_0 = (n * (n + 1)) // 2\n   \n    res = VAR_0 * (VAR_0 - 1)\n    return res", "label": 1, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def difference(n):\n    B = (n * (n + 1)) // 2\n   \n    res = B * (B - 1)\n    return res", "label": 1, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_add_sub_variable", "transformed_code": "def difference(n) :\n      \n    S = (n*(n - 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "label": 0, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_sub_add_variable", "transformed_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S+1);  \n    return res;  ", "label": 0, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_mul_div_variable", "transformed_code": "def difference(n) :\n      \n    S = (n/(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "label": 0, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_div_mul_variable", "transformed_code": "def difference(n) :\n      \n    S = (n*(n + 1))*/2;  \n    res = S*(S-1);  \n    return res;  ", "label": 0, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 552, "dataset": "mbpp"},
{"original_code": "def difference(n) :\n      \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 552, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_dead_code_insert", "transformed_code": "def toggle_string(string):\n    for _i_2 in range(0):\n        return string1\n   \n    string1 = string.swapcase()\n    return string1", "label": 1, "groups": 554, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_for_while_loop", "transformed_code": "def toggle_string(string):\n   \n    string1 = string.swapcase()\n    return string1", "label": 1, "groups": 554, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_operand_swap", "transformed_code": "def toggle_string(string):\n   \n    string1 = string.swapcase()\n    return string1", "label": 1, "groups": 554, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_rename_variable_cb", "transformed_code": "def toggle_string(line):\n   \n    string1 = line.swapcase()\n    return string1", "label": 1, "groups": 554, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_rename_variable_naive", "transformed_code": "def toggle_string(VAR_0):\n   \n    string1 = VAR_0.swapcase()\n    return string1", "label": 1, "groups": 554, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_rename_variable_rn", "transformed_code": "def toggle_string(At98e3):\n   \n    string1 = At98e3.swapcase()\n    return string1", "label": 1, "groups": 554, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 554, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 554, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 554, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 554, "dataset": "mbpp"},
{"original_code": "def toggle_string(string):\n \n string1 = string.swapcase()\n return string1", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 554, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def union_elements(test_tup1, test_tup2):\n    for _i_8 in range(0):\n        res = tuple(set(test_tup1 + test_tup2))\n   \n    res = tuple(set(test_tup1 + test_tup2))\n    return res", "label": 1, "groups": 557, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_for_while_loop", "transformed_code": "def union_elements(test_tup1, test_tup2):\n   \n    res = tuple(set(test_tup1 + test_tup2))\n    return res", "label": 1, "groups": 557, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_operand_swap", "transformed_code": "def union_elements(test_tup1, test_tup2):\n   \n    res = tuple(set(test_tup1 + test_tup2))\n    return res", "label": 1, "groups": 557, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def union_elements(test_tup1, test_tup2):\n   \n    VAR_0 = tuple(set(test_tup1 + test_tup2))\n    return VAR_0", "label": 1, "groups": 557, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def union_elements(test_tup1, test_tup2):\n   \n    lN5 = tuple(set(test_tup1 + test_tup2))\n    return lN5", "label": 1, "groups": 557, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_add_sub_variable", "transformed_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 - test_tup2))\n  return (res) ", "label": 0, "groups": 557, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 557, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 557, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 557, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 557, "dataset": "mbpp"},
{"original_code": "def union_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 557, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def assign_elements(test_list):\n    res = dict()\n    for key, val in test_list:\n        _i_2 = 0\n        while _i_2 < _i_2:\n            return res\n       \n        res.setdefault(val, [])\n        res.setdefault(key, []).append(val)\n    return res", "label": 1, "groups": 558, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_for_while_loop", "transformed_code": "def assign_elements(test_list):\n    res = dict()\n    for key, val in test_list:\n       \n        res.setdefault(val, [])\n        res.setdefault(key, []).append(val)\n    return res", "label": 1, "groups": 558, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_operand_swap", "transformed_code": "def assign_elements(test_list):\n    res = dict()\n    for key, val in test_list:\n       \n        res.setdefault(val, [])\n        res.setdefault(key, []).append(val)\n    return res", "label": 1, "groups": 558, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def assign_elements(test_list):\n    result = dict()\n    for key, val in test_list:\n       \n        result.setdefault(val, [])\n        result.setdefault(key, []).append(val)\n    return result", "label": 1, "groups": 558, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def assign_elements(test_list):\n    VAR_0 = dict()\n    for key, val in test_list:\n       \n        VAR_0.setdefault(val, [])\n        VAR_0.setdefault(key, []).append(val)\n    return VAR_0", "label": 1, "groups": 558, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def assign_elements(test_list):\n    gc6 = dict()\n    for key, val in test_list:\n       \n        gc6.setdefault(val, [])\n        gc6.setdefault(key, []).append(val)\n    return gc6", "label": 1, "groups": 558, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 558, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 558, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 558, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 558, "dataset": "mbpp"},
{"original_code": "def assign_elements(test_list):\n  \n  res = dict()\n  for key, val in test_list:\n    res.setdefault(val, [])\n    res.setdefault(key, []).append(val)\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 558, "dataset": "mbpp"},
{"original_code": "def Find_Max_Length(lst):\n      \n    maxLength = max(len(x) for x in lst )\n    return maxLength ", "transformation": "transformation_dead_code_insert", "transformed_code": "def Find_Max_Length(lst):\n    while False:\n        maxLength = max(len(x) for x in lst)\n   \nmaxLength = max(len(x) for x in lst)\nreturn maxLength", "label": 1, "groups": 559, "dataset": "mbpp"},
{"original_code": "def Find_Max_Length(lst):\n      \n    maxLength = max(len(x) for x in lst )\n    return maxLength ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 559, "dataset": "mbpp"},
{"original_code": "def Find_Max_Length(lst):\n      \n    maxLength = max(len(x) for x in lst )\n    return maxLength ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 559, "dataset": "mbpp"},
{"original_code": "def Find_Max_Length(lst):\n      \n    maxLength = max(len(x) for x in lst )\n    return maxLength ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 559, "dataset": "mbpp"},
{"original_code": "def Find_Max_Length(lst):\n      \n    maxLength = max(len(x) for x in lst )\n    return maxLength ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 559, "dataset": "mbpp"},
{"original_code": "def Find_Max_Length(lst):\n      \n    maxLength = max(len(x) for x in lst )\n    return maxLength ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 559, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_dead_code_insert", "transformed_code": "def remove_words(list1, charlist):\n    for _i_3 in range(0):\n        new_list = []\n    new_list = []\n    for line in list1:\n       \n        new_words = \" \".join(\n            [\n                word\n                for word in line.split()\n                if not any([phrase in word for phrase in charlist])\n            ]\n        )\n        new_list.append(new_words)\n    return new_list", "label": 1, "groups": 567, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_for_while_loop", "transformed_code": "def remove_words(list1, charlist):\n    new_list = []\n    _line_i = 0\n    while _line_i < len(list1):\n        line = list1[_line_i]\n       \n        new_words = \" \".join(\n            [\n                word\n                for word in line.split()\n                if not any([phrase in word for phrase in charlist])\n            ]\n        )\n        new_list.append(new_words)\n        _line_i += 1\n    return new_list", "label": 1, "groups": 567, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_operand_swap", "transformed_code": "def remove_words(list1, charlist):\n    new_list = []\n    for line in list1:\n       \n        new_words = \" \".join(\n            [\n                word\n                for word in line.split()\n                if not any([phrase in word for phrase in charlist])\n            ]\n        )\n        new_list.append(new_words)\n    return new_list", "label": 1, "groups": 567, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_rename_variable_cb", "transformed_code": "def remove_words(list1, charlist):\n    sk = []\n    for line in list1:\n       \n        new_words = \" \".join(\n            [\n                word\n                for word in line.split()\n                if not any([phrase in word for phrase in charlist])\n            ]\n        )\n        sk.append(new_words)\n    return sk", "label": 1, "groups": 567, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_rename_variable_naive", "transformed_code": "def remove_words(list1, charlist):\n    new_list = []\n    for line in list1:\n       \n        new_words = \" \".join(\n            [\n                VAR_0\n                for VAR_0 in line.split()\n                if not any([phrase in VAR_0 for phrase in charlist])\n            ]\n        )\n        new_list.append(new_words)\n    return new_list", "label": 1, "groups": 567, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_rename_variable_rn", "transformed_code": "def remove_words(list1, charlist):\n    l89pw45l = []\n    for line in list1:\n       \n        new_words = \" \".join(\n            [\n                word\n                for word in line.split()\n                if not any([phrase in word for phrase in charlist])\n            ]\n        )\n        l89pw45l.append(new_words)\n    return l89pw45l", "label": 1, "groups": 567, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 567, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 567, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 567, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 567, "dataset": "mbpp"},
{"original_code": "def remove_words(list1, charlist):\n    \n    new_list = []\n    for line in list1:\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\n        new_list.append(new_words)\n    return new_list", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 567, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_dead_code_insert", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n    arr.sort()\n    dp = [0] * N\n    dp[0] = 0\n    for i in range(1, N):\n        dp[i] = dp[i - 1]\n        if False:\n            if i >= 2:\n                dp[i] = max(dp[i], dp[i - 2] + arr[i] + arr[i - 1])\n            else:\n                dp[i] = max(dp[i], arr[i] + arr[i - 1])\n       \n        if arr[i] - arr[i - 1] < K:\n            if i >= 2:\n                dp[i] = max(dp[i], dp[i - 2] + arr[i] + arr[i - 1])\n            else:\n                dp[i] = max(dp[i], arr[i] + arr[i - 1])\n    return dp[N - 1]", "label": 1, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_for_while_loop", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n    arr.sort()\n    dp = [0] * N\n    dp[0] = 0\n    i = 1\n    while i < N:\n        dp[i] = dp[i - 1]\n       \n        if arr[i] - arr[i - 1] < K:\n            if i >= 2:\n                dp[i] = max(dp[i], dp[i - 2] + arr[i] + arr[i - 1])\n            else:\n                dp[i] = max(dp[i], arr[i] + arr[i - 1])\n        i += 1\n    return dp[N - 1]", "label": 1, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_operand_swap", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n    arr.sort()\n    dp = [0] * N\n    dp[0] = 0\n    for i in range(1, N):\n        dp[i] = dp[i - 1]\n       \n        if K > arr[i] - arr[i - 1]:\n            if i >= 2:\n                dp[i] = max(dp[i], dp[i - 2] + arr[i] + arr[i - 1])\n            else:\n                dp[i] = max(dp[i], arr[i] + arr[i - 1])\n    return dp[N - 1]", "label": 1, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_rename_variable_cb", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n    arr.sort()\n    dp = [0] * N\n    dp[0] = 0\n    for i2 in range(1, N):\n        dp[i2] = dp[i2 - 1]\n       \n        if arr[i2] - arr[i2 - 1] < K:\n            if i2 >= 2:\n                dp[i2] = max(dp[i2], dp[i2 - 2] + arr[i2] + arr[i2 - 1])\n            else:\n                dp[i2] = max(dp[i2], arr[i2] + arr[i2 - 1])\n    return dp[N - 1]", "label": 1, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_rename_variable_naive", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n    arr.sort()\n    dp = [0] * N\n    dp[0] = 0\n    for VAR_0 in range(1, N):\n        dp[VAR_0] = dp[VAR_0 - 1]\n       \n        if arr[VAR_0] - arr[VAR_0 - 1] < K:\n            if VAR_0 >= 2:\n                dp[VAR_0] = max(dp[VAR_0], dp[VAR_0 - 2] + arr[VAR_0] + arr[VAR_0 - 1])\n            else:\n                dp[VAR_0] = max(dp[VAR_0], arr[VAR_0] + arr[VAR_0 - 1])\n    return dp[N - 1]", "label": 1, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_rename_variable_rn", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n    arr.sort()\n    dp = [0] * N\n    dp[0] = 0\n    for d in range(1, N):\n        dp[d] = dp[d - 1]\n       \n        if arr[d] - arr[d - 1] < K:\n            if d >= 2:\n                dp[d] = max(dp[d], dp[d - 2] + arr[d] + arr[d - 1])\n            else:\n                dp[d] = max(dp[d], arr[d] + arr[d - 1])\n    return dp[N - 1]", "label": 1, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_add_sub_variable", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] - arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "label": 0, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_sub_add_variable", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i+1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "label": 0, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_mul_div_variable", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] / N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "label": 0, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] > K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "label": 0, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_greater_lesser_variable", "transformed_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i <= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "label": 0, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 568, "dataset": "mbpp"},
{"original_code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\t \n\tarr.sort() \n\tdp = [0] * N \n\tdp[0] = 0\n\tfor i in range(1, N): \n\t\tdp[i] = dp[i-1] \n\t\tif (arr[i] - arr[i-1] < K): \n\t\t\tif (i >= 2): \n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]); \n\t\t\telse: \n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]); \n\treturn dp[N - 1]", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 568, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_dead_code_insert", "transformed_code": "def unique_product(list_data):\n    temp = list(set(list_data))\n    p = 1\n    if False:\n        p *= i\n   \n    for i in temp:\n        p *= i\n    return p", "label": 1, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_for_while_loop", "transformed_code": "def unique_product(list_data):\n    temp = list(set(list_data))\n    p = 1\n   \n    _i_i = 0\n    while _i_i < len(temp):\n        i = temp[_i_i]\n        p *= i\n        _i_i += 1\n    return p", "label": 1, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_operand_swap", "transformed_code": "def unique_product(list_data):\n    temp = list(set(list_data))\n    p = 1\n   \n    for i in temp:\n        p *= i\n    return p", "label": 1, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_rename_variable_cb", "transformed_code": "def unique_product(list_data):\n    temp = list(set(list_data))\n    ps = 1\n   \n    for i in temp:\n        ps *= i\n    return ps", "label": 1, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_rename_variable_naive", "transformed_code": "def unique_product(list_data):\n    temp = list(set(list_data))\n    VAR_0 = 1\n   \n    for i in temp:\n        VAR_0 *= i\n    return VAR_0", "label": 1, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_rename_variable_rn", "transformed_code": "def unique_product(list_data):\n    temp = list(set(list_data))\n    m = 1\n   \n    for i in temp:\n        m *= i\n    return m", "label": 1, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_mul_div_variable", "transformed_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p /= i\n    return p", "label": 0, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 570, "dataset": "mbpp"},
{"original_code": "def unique_product(list_data):\n    \n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 570, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def count_no(A, N, L, R):\n    count = 0\n    for i in range(L, R + 1):\n        if i % A != 0:\n            _i_1 = 0\n            while _i_1 < _i_1:\n                return i\n           \n            count += 1\n        if count == N:\n            break\n    return i", "label": 1, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_for_while_loop", "transformed_code": "def count_no(A, N, L, R):\n    count = 0\n    i = L\n    while i < R + 1:\n        if i % A != 0:\n           \n            count += 1\n        if count == N:\n            break\n        i += 1\n    return i", "label": 1, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_operand_swap", "transformed_code": "def count_no(A, N, L, R):\n    count = 0\n    for i in range(L, R + 1):\n        if 0 != i % A:\n           \n            count += 1\n        if count == N:\n            break\n    return i", "label": 1, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_rename_variable_cb", "transformed_code": "def count_no(A, N, L, R):\n    count = 0\n    for n in range(L, R + 1):\n        if n % A != 0:\n           \n            count += 1\n        if count == N:\n            break\n    return n", "label": 1, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def count_no(A, N, L, R):\n    VAR_0 = 0\n    for i in range(L, R + 1):\n        if i % A != 0:\n           \n            VAR_0 += 1\n        if VAR_0 == N:\n            break\n    return i", "label": 1, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def count_no(A, N, L, R):\n    count = 0\n    for G in range(L, R + 1):\n        if G % A != 0:\n           \n            count += 1\n        if count == N:\n            break\n    return G", "label": 1, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_add_sub_variable", "transformed_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R - 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "label": 0, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_equalto_exclamation_variable", "transformed_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count != N): \n            break\n    return (i) ", "label": 0, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_exclamation_equalto_variable", "transformed_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A == 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "label": 0, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 572, "dataset": "mbpp"},
{"original_code": "def count_no (A,N,L,R):\n     \n    count = 0\n    for i in range (L,R + 1): \n        if (i % A != 0): \n            count += 1\n        if (count == N): \n            break\n    return (i) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 572, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_dead_code_insert", "transformed_code": "def interleave_lists(list1, list2, list3):\n    _i_2 = 0\n    if _i_2 < _i_2:\n        return result\n   \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "label": 1, "groups": 575, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_for_while_loop", "transformed_code": "def interleave_lists(list1, list2, list3):\n   \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "label": 1, "groups": 575, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_operand_swap", "transformed_code": "def interleave_lists(list1, list2, list3):\n   \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "label": 1, "groups": 575, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_rename_variable_cb", "transformed_code": "def interleave_lists(list1, list2, list3):\n   \n    result = [i for pair in zip(list1, list2, list3) for i in pair]\n    return result", "label": 1, "groups": 575, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_rename_variable_naive", "transformed_code": "def interleave_lists(list1, list2, VAR_0):\n   \n    result = [el for pair in zip(list1, list2, VAR_0) for el in pair]\n    return result", "label": 1, "groups": 575, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_rename_variable_rn", "transformed_code": "def interleave_lists(list1, list2, H7116):\n   \n    result = [el for pair in zip(list1, list2, H7116) for el in pair]\n    return result", "label": 1, "groups": 575, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 575, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 575, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 575, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 575, "dataset": "mbpp"},
{"original_code": "def interleave_lists(list1,list2,list3):\n    \n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 575, "dataset": "mbpp"},
{"original_code": "def find_dissimilar(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def find_dissimilar(test_tup1, test_tup2):\n    for _i_5 in range(0):\n        return res\n   \n    res = tuple(set(test_tup1) ^ set(test_tup2))\n    return res", "label": 1, "groups": 576, "dataset": "mbpp"},
{"original_code": "def find_dissimilar(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "transformation": "transformation_for_while_loop", "transformed_code": "def find_dissimilar(test_tup1, test_tup2):\n   \n    res = tuple(set(test_tup1) ^ set(test_tup2))\n    return res", "label": 1, "groups": 576, "dataset": "mbpp"},
{"original_code": "def find_dissimilar(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "transformation": "transformation_operand_swap", "transformed_code": "def find_dissimilar(test_tup1, test_tup2):\n   \n    res = tuple(set(test_tup1) ^ set(test_tup2))\n    return res", "label": 1, "groups": 576, "dataset": "mbpp"},
{"original_code": "def find_dissimilar(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "transformation": "transformation_rename_variable_naive", "transformed_code": "def find_dissimilar(test_tup1, test_tup2):\n   \n    VAR_0 = tuple(set(test_tup1) ^ set(test_tup2))\n    return VAR_0", "label": 1, "groups": 576, "dataset": "mbpp"},
{"original_code": "def find_dissimilar(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "transformation": "transformation_rename_variable_rn", "transformed_code": "def find_dissimilar(test_tup1, test_tup2):\n   \n    j08 = tuple(set(test_tup1) ^ set(test_tup2))\n    return j08", "label": 1, "groups": 576, "dataset": "mbpp"},
{"original_code": "def find_dissimilar(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 576, "dataset": "mbpp"},
{"original_code": "def find_dissimilar(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 576, "dataset": "mbpp"},
{"original_code": "def find_dissimilar(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 576, "dataset": "mbpp"},
{"original_code": "def find_dissimilar(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 576, "dataset": "mbpp"},
{"original_code": "def find_dissimilar(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 576, "dataset": "mbpp"},
{"original_code": "def surface_Area(b,s):\n     \n    return 2 * b * s + pow(b,2) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def surface_Area(b, s):\n    for _i_5 in range(0):\n        return 2 * b * s + pow(b, 2)\n   \nreturn 2 * b * s + pow(b, 2)", "label": 1, "groups": 578, "dataset": "mbpp"},
{"original_code": "def surface_Area(b,s):\n     \n    return 2 * b * s + pow(b,2) ", "transformation": "transformation_add_sub_variable", "transformed_code": "def surface_Area(b,s):\n     \n    return 2 * b * s - pow(b,2) ", "label": 0, "groups": 578, "dataset": "mbpp"},
{"original_code": "def surface_Area(b,s):\n     \n    return 2 * b * s + pow(b,2) ", "transformation": "transformation_mul_div_variable", "transformed_code": "def surface_Area(b,s):\n     \n    return 2 / b * s + pow(b,2) ", "label": 0, "groups": 578, "dataset": "mbpp"},
{"original_code": "def surface_Area(b,s):\n     \n    return 2 * b * s + pow(b,2) ", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 578, "dataset": "mbpp"},
{"original_code": "def surface_Area(b,s):\n     \n    return 2 * b * s + pow(b,2) ", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 578, "dataset": "mbpp"},
{"original_code": "def surface_Area(b,s):\n     \n    return 2 * b * s + pow(b,2) ", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 578, "dataset": "mbpp"},
{"original_code": "def surface_Area(b,s):\n     \n    return 2 * b * s + pow(b,2) ", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 578, "dataset": "mbpp"},
{"original_code": "def surface_Area(b,s):\n     \n    return 2 * b * s + pow(b,2) ", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 578, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_dead_code_insert", "transformed_code": "def catalan_number(num):\n    _i_7 = 0\n    while _i_7 > _i_7:\n        res_num = 0\n    if num <= 1:\n        return 1\n       \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num - i - 1)\n    return res_num", "label": 1, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_for_while_loop", "transformed_code": "def catalan_number(num):\n    if num <= 1:\n        return 1\n       \n    res_num = 0\n    i = 0\n    while i < num:\n        res_num += catalan_number(i) * catalan_number(num - i - 1)\n        i += 1\n    return res_num", "label": 1, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_operand_swap", "transformed_code": "def catalan_number(num):\n    if 1 >= num:\n        return 1\n       \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num - i - 1)\n    return res_num", "label": 1, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_rename_variable_cb", "transformed_code": "def catalan_number(i2):\n    if i2 <= 1:\n        return 1\n       \n    res_num = 0\n    for i in range(i2):\n        res_num += catalan_number(i) * catalan_number(i2 - i - 1)\n    return res_num", "label": 1, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_rename_variable_naive", "transformed_code": "def catalan_number(VAR_0):\n    if VAR_0 <= 1:\n        return 1\n       \n    res_num = 0\n    for i in range(VAR_0):\n        res_num += catalan_number(i) * catalan_number(VAR_0 - i - 1)\n    return res_num", "label": 1, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_rename_variable_rn", "transformed_code": "def catalan_number(a1M):\n    if a1M <= 1:\n        return 1\n       \n    res_num = 0\n    for i in range(a1M):\n        res_num += catalan_number(i) * catalan_number(a1M - i - 1)\n    return res_num", "label": 1, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_add_sub_variable", "transformed_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num -= catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "label": 0, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_sub_add_variable", "transformed_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num+i-1)\n    return res_num", "label": 0, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_mul_div_variable", "transformed_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) / catalan_number(num-i-1)\n    return res_num", "label": 0, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_lesser_greater_variable", "transformed_code": "def catalan_number(num):\n    \n    if num >=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "label": 0, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 580, "dataset": "mbpp"},
{"original_code": "def catalan_number(num):\n    \n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 580, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_dead_code_insert", "transformed_code": "def find_adverbs(text):\n    for _i_9 in range(0):\n        return \"%d-%d: %s\" % (m.start(), m.end(), m.group(0))\n    import re\n   \n    for m in re.finditer(r\"w+ly\", text):\n        return \"%d-%d: %s\" % (m.start(), m.end(), m.group(0))", "label": 1, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_for_while_loop", "transformed_code": "def find_adverbs(text):\n    import re\n   \n    _m_i = 0\n    while _m_i < len(re.finditer(r\"w+ly\", text)):\n        m = re.finditer(r\"w+ly\", text)[_m_i]\n        return \"%d-%d: %s\" % (m.start(), m.end(), m.group(0))\n        _m_i += 1", "label": 1, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_operand_swap", "transformed_code": "def find_adverbs(text):\n    import re\n   \n    for m in re.finditer(r\"w+ly\", text):\n        return \"%d-%d: %s\" % (m.start(), m.end(), m.group(0))", "label": 1, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_rename_variable_cb", "transformed_code": "def find_adverbs(text):\n    import re\n   \n    for r in re.finditer(r\"w+ly\", text):\n        return \"%d-%d: %s\" % (r.start(), r.end(), r.group(0))", "label": 1, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_rename_variable_naive", "transformed_code": "def find_adverbs(text):\n    import re\n   \n    for VAR_0 in re.finditer(r\"w+ly\", text):\n        return \"%d-%d: %s\" % (VAR_0.start(), VAR_0.end(), VAR_0.group(0))", "label": 1, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_rename_variable_rn", "transformed_code": "def find_adverbs(text):\n    import re\n   \n    for U in re.finditer(r\"w+ly\", text):\n        return \"%d-%d: %s\" % (U.start(), U.end(), U.group(0))", "label": 1, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_add_sub_variable", "transformed_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w-ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "label": 0, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_sub_add_variable", "transformed_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d+%d: %s' % (m.start(), m.end(), m.group(0)))", "label": 0, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 581, "dataset": "mbpp"},
{"original_code": "def find_adverbs(text):\n  import re\n  \n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 581, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_dead_code_insert", "transformed_code": "def expensive_items(items, n):\n    _i_2 = 0\n    if _i_2 > _i_2:\n        return expensive_items\n    import heapq\n   \n    expensive_items = heapq.nlargest(n, items, key=lambda s: s[\"price\"])\n    return expensive_items", "label": 1, "groups": 582, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_for_while_loop", "transformed_code": "def expensive_items(items, n):\n    import heapq\n   \n    expensive_items = heapq.nlargest(n, items, key=lambda s: s[\"price\"])\n    return expensive_items", "label": 1, "groups": 582, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_operand_swap", "transformed_code": "def expensive_items(items, n):\n    import heapq\n   \n    expensive_items = heapq.nlargest(n, items, key=lambda s: s[\"price\"])\n    return expensive_items", "label": 1, "groups": 582, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_rename_variable_cb", "transformed_code": "def expensive_items(items, n):\n    import heapq\n   \n    expensive_items = heapq.nlargest(n, items, key=lambda x: x[\"price\"])\n    return expensive_items", "label": 1, "groups": 582, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_rename_variable_naive", "transformed_code": "def expensive_items(items, VAR_0):\n    import heapq\n   \n    expensive_items = heapq.nlargest(VAR_0, items, key=lambda s: s[\"price\"])\n    return expensive_items", "label": 1, "groups": 582, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_rename_variable_rn", "transformed_code": "def expensive_items(items, b):\n    import heapq\n   \n    expensive_items = heapq.nlargest(b, items, key=lambda s: s[\"price\"])\n    return expensive_items", "label": 1, "groups": 582, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_dissimilar_code_injection_0", "transformed_code": "def min_cost(cost, m, n):\n\tR = 3\n\tC = 3\n\t \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "label": 0, "groups": 582, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_dissimilar_code_injection_1", "transformed_code": "def similar_elements(test_tup1, test_tup2):\n  \n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "label": 0, "groups": 582, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_dissimilar_code_injection_2", "transformed_code": "def is_not_prime(n):\n    import math\n    \n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "label": 0, "groups": 582, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_dissimilar_code_injection_3", "transformed_code": "def heap_queue_largest(nums,n):\n  import heapq as hq\n  \n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "label": 0, "groups": 582, "dataset": "mbpp"},
{"original_code": "def expensive_items(items,n):\n  import heapq\n  \n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "transformation": "transformation_dissimilar_code_injection_4", "transformed_code": "def count_ways(n):\n\t \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n] ", "label": 0, "groups": 582, "dataset": "mbpp"},
{"original_code": "def split_Arr(a,n,k):\n     \n   b = a[:k] \n   return (a[k::]+b[::]) ", "transformation": "transformation_dead_code_insert", "transformed_code": "def split_Arr(a, n, k):\n    _i_6 = 0\n    if _i_6 > _i_6:\n        b = a[:k]\n   \nb = a[:k]\nreturn a[k::] + b[::]", "label": 1, "groups": 583, "dataset": "mbpp"},
{"original_code": "def split_Arr(a,n,k):\n     \n   b = a[:k] \n   return (a[k::]+b[::]) ", "transformation": "transformation_add_sub_variable", "transformed_code": "def split_Arr(a,n,k):\n     \n   b = a[:k] \n   return (a[k::]-b[::]) ", "label": 0, "groups": 583, "dataset": "mbpp"},
    ];
